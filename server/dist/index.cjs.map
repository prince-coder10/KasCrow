{"version":3,"file":"index.cjs","names":["RpcClient","Resolver","ws","WebSocket","listener: KaspaRpcEventListener","router: Router","router","error: any","ESCROW_TRANSITIONS: Record<string, Record<string, Actor[]>>","Schema","User","TR_STATUS","PrivateKey","actor: Actor","User","TR_STATUS","PrivateKey","allowFundsRelease","finalSettlement: IFinalSettlement","SettlementService","Schema","TR_STATUS","Escrow","updateFields: Partial<IEscrow>","TR_STATUS","Escrow","Schema","escrowStore: EscrowStore","SettlementService: SettlementService","PrivateKey","TR_STATUS","Release.allowFundsRelease","Refund.executeRefund","User","Funding.executeFundingUpdate","Release.executeRelease","Escrow","z","settlementStore: SettlementStore","fileStore: FileStorageService","settlementData: Record<string, any>","Settlement_Type","Schema","Settlement","Settlement","Settlement","Escrow","Settlement","Escrow","Settlement","Escrow","err: any","Settlement","Escrow","settlementInput: ISettlementDataInput","Settlement","Escrow","jwt","cookieName","User","Settlement","Escrow","Settlement","Escrow","router: Router","userStore: UserStore","User","User","cookieName","authRoute: Router","app: Express","swaggerUi","kaspaRoutes","escrowRoutes","authRoutes","WebSocket","ws","err: any","utxo: IEscrowUTXO","cron"],"sources":["../src/services/kaspaRpcService.ts","../src/routes/kaspaRoutes.ts","../src/config/TR_STATUSES.ts","../src/escrow/escrow.utils.ts","../src/utils/bufferCalculator.ts","../src/errors/AppError.ts","../src/errors/auth.erros.ts","../src/escrow/machine/escrow.fsm.ts","../src/auth/User.model.ts","../src/config/options.ts","../src/escrow/services/escrow.helpers.ts","../src/escrow/services/escrow.refund.ts","../src/escrow/services/escrow.release.ts","../src/escrow/model/Escrow.ts","../src/escrow/services/escrow.funding.ts","../src/escrow/model/Subscription.ts","../src/escrow/services/kaspaAddressListener.ts","../src/escrow/services/escrow.service.ts","../src/escrow/escrow.store.ts","../src/utils/catchError.ts","../src/utils/zod.ts","../src/settlement/settlement.service.ts","../src/settlement/model/Settlement.ts","../src/settlement/settlement.store.ts","../src/settlement/files/fileStore.service.ts","../src/escrow/controllers/createEscrow.ts","../src/escrow/controllers/getEscrowStatus.ts","../src/escrow/controllers/releaseEscrow.ts","../src/escrow/controllers/vendorAck.ts","../src/escrow/controllers/allowRelease.ts","../src/utils/jwt.ts","../src/middleware/requireAuth.ts","../src/escrow/controllers/getUserEscrows.ts","../src/middleware/upload.ts","../src/escrow/controllers/dashboard.controller.ts","../src/routes/escrow.routes.ts","../src/auth/auth.service.ts","../src/auth/auth.store.ts","../src/auth/controllers/login.controller.ts","../src/auth/controllers/logout.controller.ts","../src/auth/controllers/profile.controller.ts","../src/routes/auth.routes.ts","../src/app.ts","../src/escrow/escrow.listener.ts","../src/config/mongo.ts","../src/escrow/workers/escrowExpiry.worker.ts","../src/index.ts"],"sourcesContent":["import kaspa, {\n  Resolver,\n  RpcClient,\n  type RpcEventMap,\n} from \"@kluster/kaspa-wasm-node\";\nimport * as WebSocket from \"ws\";\n\ntype KaspaRpcEventListener = (event: any) => void;\n\nclass KaspaRpcService {\n  private rpc: RpcClient | null = null;\n  private isConnected: boolean = false;\n  private subscribers: Map<string, Set<WebSocket.WebSocket>> = new Map();\n  private rpcEventListeners: Map<string, KaspaRpcEventListener> = new Map();\n  private addressSubscribers: Map<string, Set<WebSocket.WebSocket>> = new Map();\n\n  constructor() {\n    kaspa.initConsolePanicHook();\n  }\n\n  public getCurrentURL() {\n    return this.rpc?.url;\n  }\n\n  public async connect() {\n    if (this.isConnected) {\n      console.log(\"Kaspa RPC Client already connected.\");\n      return;\n    }\n\n    this.rpc = new RpcClient({\n      // hint: you can change to a node url of yours\n      // url: \"ws://<url>\",\n      resolver: new Resolver(),\n      networkId: \"testnet-10\", //\"mainnet\"\n    });\n\n    try {\n      await this.rpc.connect({\n        timeoutDuration: 2000,\n        blockAsyncConnect: true,\n      });\n      this.isConnected = true;\n      console.log(\"Kaspa RPC Client Connected.\");\n    } catch (error) {\n      console.error(\"Failed to connect to Kaspa RPC client:\", error);\n      this.isConnected = false;\n      throw error;\n    }\n  }\n\n  public getRpcClient(): RpcClient {\n    if (!this.rpc || !this.isConnected) {\n      throw new Error(\"Kaspa RPC Client is not connected.\");\n    }\n    return this.rpc;\n  }\n\n  public isRpcConnected(): boolean {\n    return this.isConnected;\n  }\n\n  public async getBlockDagInfo() {\n    const rpc = this.getRpcClient();\n    return rpc.getBlockDagInfo();\n  }\n\n  public async getBalancesByAddresses(addresses: string[]) {\n    const rpc = this.getRpcClient();\n    return rpc.getBalancesByAddresses({ addresses });\n  }\n\n  private broadcast(eventName: string, data: any) {\n    const clients = this.subscribers.get(eventName);\n    if (clients) {\n      clients.forEach((ws) => {\n        if (ws.readyState === WebSocket.WebSocket.OPEN) {\n          ws.send(JSON.stringify({ event: eventName, data }));\n        }\n      });\n    }\n  }\n\n  public async initGlobalUtxoListener() {\n    const rpc = this.getRpcClient();\n\n    rpc.addEventListener(\"utxos-changed\", async (event: any) => {\n      const affectedAddresses = new Set<string>();\n\n      // Ensure we handle addresses as strings (some SDK versions return Address objects)\n      event.data.added?.forEach((u: any) => {\n        const addr =\n          typeof u.address === \"string\" ? u.address : u.address.toString();\n        affectedAddresses.add(addr);\n      });\n\n      event.data.removed?.forEach((u: any) => {\n        const addr =\n          typeof u.address === \"string\" ? u.address : u.address.toString();\n        affectedAddresses.add(addr);\n      });\n\n      for (const address of affectedAddresses) {\n        const clients = this.addressSubscribers.get(address);\n        if (clients && clients.size > 0) {\n          try {\n            const balanceData = await this.getBalancesByAddresses([address]);\n\n            const payload = JSON.stringify({\n              type: \"balance-update\",\n              address: address,\n              data: balanceData,\n            });\n\n            clients.forEach((ws) => {\n              // FIX: Use WebSocket.WebSocket.OPEN to match your import style\n              if (ws.readyState === WebSocket.WebSocket.OPEN) {\n                ws.send(payload);\n              }\n            });\n          } catch (err) {\n            console.error(\n              `‚ùå Failed to push balance update for ${address}:`,\n              err,\n            );\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Call this when a client specifically wants to \"watch\" an address for balance changes\n   */\n  public async watchAddress(address: string, ws: WebSocket.WebSocket) {\n    if (!this.addressSubscribers.has(address)) {\n      this.addressSubscribers.set(address, new Set());\n\n      // Tell Kaspa RPC to start monitoring this address\n      // The Wasm SDK expects an object with an addresses array\n      await this.getRpcClient().subscribeUtxosChanged([address]);\n    }\n\n    this.addressSubscribers.get(address)?.add(ws);\n  }\n\n  public unwatchAddress(address: string, ws: WebSocket.WebSocket) {\n    const clients = this.addressSubscribers.get(address);\n    if (clients) {\n      clients.delete(ws);\n      // Optional: if (clients.size === 0) unsubscribe from RPC to save bandwidth\n    }\n  }\n\n  /**\n   * Removes a WebSocket client from all address subscriptions.\n   * Called when a user disconnects or leaves the escrow page.\n   */\n  public unwatchAll(ws: WebSocket.WebSocket) {\n    let count = 0;\n\n    this.addressSubscribers.forEach((clients, address) => {\n      if (clients.has(ws)) {\n        clients.delete(ws);\n        count++;\n\n        // Optimization: If no one is watching this address anymore,\n        // remove the entry from the map.\n        if (clients.size === 0) {\n          this.addressSubscribers.delete(address);\n          // Optional: Call rpc.unsubscribeUtxosChanged([address])\n          // if you want to be extremely aggressive with RPC efficiency.\n        }\n      }\n    });\n\n    if (count > 0) {\n      console.log(\n        `üßπ Cleaned up ${count} address subscriptions for disconnected client.`,\n      );\n    }\n  }\n\n  public subscribe(eventName: keyof RpcEventMap, ws: WebSocket.WebSocket) {\n    if (!this.subscribers.has(eventName)) {\n      this.subscribers.set(eventName, new Set());\n      this.setupRpcEventListener(eventName);\n    }\n    this.subscribers.get(eventName)?.add(ws);\n    console.log(\n      `WebSocket subscribed to ${eventName}. Total subscribers: ${this.subscribers.get(eventName)?.size}`,\n    );\n  }\n\n  public unsubscribe(eventName: string, ws: WebSocket.WebSocket) {\n    const clients = this.subscribers.get(eventName);\n    if (clients) {\n      clients.delete(ws);\n      if (clients.size === 0) {\n        this.subscribers.delete(eventName);\n        this.removeRpcEventListener(eventName);\n      }\n    }\n    console.log(\n      `WebSocket unsubscribed from ${eventName}. Remaining subscribers: ${this.subscribers.get(eventName)?.size || 0}`,\n    );\n  }\n\n  private setupRpcEventListener(eventName: keyof RpcEventMap) {\n    if (!this.rpcEventListeners.has(eventName)) {\n      const listener: KaspaRpcEventListener = (event: any) => {\n        this.broadcast(eventName, event.data);\n      };\n      this.rpcEventListeners.set(eventName, listener);\n      this.getRpcClient().addEventListener(eventName, listener);\n      console.log(`Kaspa RPC client event listener added for ${eventName}`);\n\n      // Call the corresponding subscribe method on the RPC client\n      this.activateRpcSubscription(eventName);\n    }\n  }\n\n  private removeRpcEventListener(eventName: string) {\n    const listener = this.rpcEventListeners.get(eventName);\n    if (listener) {\n      this.getRpcClient().removeEventListener(eventName, listener);\n      this.rpcEventListeners.delete(eventName);\n      console.log(`Kaspa RPC client event listener removed for ${eventName}`);\n    }\n  }\n\n  private async activateRpcSubscription(eventName: string) {\n    try {\n      switch (eventName) {\n        case \"block-added\":\n          await this.getRpcClient().subscribeBlockAdded();\n          break;\n        case \"virtual-daa-score-changed\":\n          await this.getRpcClient().subscribeVirtualDaaScoreChanged();\n          break;\n        case \"virtual-chain-changed\":\n          await this.getRpcClient().subscribeVirtualChainChanged(true);\n          break;\n        // Add other RPC subscription cases here\n        default:\n          console.warn(\n            `Attempted to activate unknown RPC subscription: ${eventName}`,\n          );\n      }\n      console.log(`Activated RPC subscription for ${eventName}`);\n    } catch (error) {\n      console.error(\n        `Error activating RPC subscription for ${eventName}:`,\n        error,\n      );\n    }\n  }\n}\n\nexport const kaspaRpcService = new KaspaRpcService();\n","import { Router, Request, Response } from \"express\";\nimport { kaspaRpcService } from \"../services/kaspaRpcService.js\";\n\nconst router: Router = Router();\n\n/**\n * @swagger\n * /kaspa/daginfo:\n *   get:\n *     summary: Retrieve Kaspa Block DAG information\n *     tags:\n *       - Kaspa RPC\n *     responses:\n *       200:\n *         description: Successfully retrieved Block DAG information.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 networkName:\n *                   type: string\n *                   example: mainnet\n *                 daaScore:\n *                   type: string\n *                   example: \"1234567890\"\n *                 blockCount:\n *                   type: string\n *                   example: \"1000000\"\n *       500:\n *         description: Internal server error.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 error:\n *                   type: string\n *                   example: \"Failed to retrieve DAG info\"\n */\nrouter.get(\"/daginfo\", async (req: Request, res: Response) => {\n  try {\n    if (!kaspaRpcService.isRpcConnected()) {\n      return res\n        .status(500)\n        .json({ error: \"Kaspa RPC client is not connected.\" });\n    }\n    const dagInfo = await kaspaRpcService.getBlockDagInfo();\n    res.json(dagInfo);\n  } catch (error: any) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n/**\n * @swagger\n * /kaspa/balances:\n *   post:\n *     summary: Retrieve Kaspa balances for given addresses\n *     tags:\n *       - Kaspa RPC\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - addresses\n *             properties:\n *               addresses:\n *                 type: array\n *                 items:\n *                   type: string\n *                 example: [\"kaspa:qpamkvhgh0kzx50gwvvp5xs8ktmqutcy3dfs9dc3w7lm9rq0zs76vf959mmrp\"]\n *     responses:\n *       200:\n *         description: Successfully retrieved balances.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 # Define properties based on IGetBalancesByAddressesResponse if available\n *                 # For now, a generic example:\n *                 entries:\n *                   type: array\n *                   items:\n *                     type: object\n *                     properties:\n *                       address:\n *                         type: string\n *                       balance:\n *                         type: string\n *                         format: int64\n *       400:\n *         description: Invalid request body.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 error:\n *                   type: string\n *                   example: \"Addresses are required\"\n *       500:\n *         description: Internal server error.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 error:\n *                   type: string\n *                   example: \"Failed to retrieve balances\"\n */\nrouter.post(\"/balances\", async (req: Request, res: Response) => {\n  try {\n    if (!kaspaRpcService.isRpcConnected()) {\n      return res\n        .status(500)\n        .json({ error: \"Kaspa RPC client is not connected.\" });\n    }\n    const { addresses } = req.body;\n    if (!addresses || !Array.isArray(addresses) || addresses.length === 0) {\n      return res.status(400).json({ error: \"Addresses array is required.\" });\n    }\n    const balances = await kaspaRpcService.getBalancesByAddresses(addresses);\n    res.json(balances);\n  } catch (error: any) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\nexport default router;\n","const TR_STATUS = {\n  CREATED: \"CREATED\",\n  AWAITING_PAYMENT: \"AWAITING_PAYMENT\",\n  PARTIALLY_FUNDED: \"PARTIALLY_FUNDED\",\n  FUNDED: \"FUNDED\",\n  // VENDOR_ACKNOWLEDGES: \"VENDOR_ACKNOWLEDGES\",\n  AWAITING_RELEASE: \"AWAITING_RELEASE\",\n  RELEASED: \"RELEASED\",\n  REFUNDED: \"REFUNDED\",\n  DISPUTED: \"DISPUTED\",\n  EXPIRED: \"EXPIRED\",\n} as const;\n\nexport type EscrowStatus = keyof typeof TR_STATUS;\n\nexport default TR_STATUS;\n","import argon2 from \"argon2\";\nimport crypto from \"crypto\";\n\nconst KEY_LENGTH = 32; // 32 bytes = 256 bits\nconst ALGORITHM = \"aes-256-gcm\";\n\nconst SALT = Buffer.from(\n  process.env.ESCROW_KEY_SALT || \"playerflip-escrow-salt\",\n);\n\nexport const deriveKey = async (): Promise<Buffer> => {\n  const masterSecret = process.env.ESCROW_MASTER_SECRET;\n  if (!masterSecret) {\n    throw new Error(\"ESCROW_MASTER_SECRET not set\");\n  }\n\n  return argon2.hash(masterSecret, {\n    type: argon2.argon2id,\n    salt: SALT,\n    memoryCost: 2 ** 16,\n    timeCost: 3,\n    parallelism: 1,\n    hashLength: KEY_LENGTH,\n    raw: true,\n  });\n};\n\nexport const encrypt = async (text: string): Promise<string> => {\n  const key = await deriveKey();\n  const iv = crypto.randomBytes(12);\n\n  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n  const encrypted = Buffer.concat([\n    cipher.update(text, \"utf8\"),\n    cipher.final(),\n  ]);\n  const tag = cipher.getAuthTag();\n\n  return Buffer.concat([iv, tag, encrypted]).toString(\"base64\");\n};\n\nexport const decrypt = async (payload: string): Promise<string> => {\n  const key = await deriveKey();\n  const data = Buffer.from(payload, \"base64\");\n\n  const iv = data.subarray(0, 12);\n  const tag = data.subarray(12, 28);\n  const encrypted = data.subarray(28);\n\n  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n  decipher.setAuthTag(tag);\n\n  const decrypted = Buffer.concat([\n    decipher.update(encrypted),\n    decipher.final(),\n  ]);\n\n  return decrypted.toString(\"utf8\");\n};\n","const EXPECTED_TX_COUNT = 3;\nconst ESTIMATED_TX_FEE_KAS = 0.00001;\nconst SAFETY_MULTIPLIER = 1.25;\n\nexport const escrowFeeBuffer =\n  EXPECTED_TX_COUNT * ESTIMATED_TX_FEE_KAS * SAFETY_MULTIPLIER;\n","export default class AppError extends Error {\n  public readonly statusCode: number;\n  public readonly isOperational: boolean;\n\n  constructor(message: string, statusCode: number) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = true;\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n","// src/errors/auth.errors.ts\nimport AppError from \"./AppError.js\";\n\nexport class UnauthorizedError extends AppError {\n  constructor(message = \"Unauthorized\") {\n    super(message, 401);\n  }\n}\n\nexport class ForbiddenError extends AppError {\n  constructor(message = \"Forbidden\") {\n    super(message, 403);\n  }\n}\n\nexport class NotFoundError extends AppError {\n  constructor(message = \"Resource not found\") {\n    super(message, 404);\n  }\n}\n\nexport class BadRequestError extends AppError {\n  constructor(message = \"Bad Request\") {\n    super(message, 400);\n  }\n}\n\nexport class InternalServerError extends AppError {\n  constructor(message = \"Internal server error\") {\n    super(message, 500);\n  }\n}\n","import { IEscrow } from \"../model/Escrow.js\";\nimport type { EscrowStatus } from \"../../config/TR_STATUSES.js\";\n\nexport type Actor = \"buyer\" | \"vendor\" | \"system\" | \"admin\";\n\nconst ESCROW_TRANSITIONS: Record<string, Record<string, Actor[]>> = {\n  CREATED: {\n    AWAITING_PAYMENT: [\"vendor\"],\n    EXPIRED: [\"system\"],\n  },\n\n  AWAITING_PAYMENT: {\n    PARTIALLY_FUNDED: [\"system\"],\n    FUNDED: [\"system\"],\n    EXPIRED: [\"system\"],\n  },\n\n  PARTIALLY_FUNDED: {\n    FUNDED: [\"system\"],\n    EXPIRED: [\"system\"],\n  },\n\n  FUNDED: {\n    AWAITING_RELEASE: [\"buyer\"],\n    DISPUTED: [\"buyer\", \"vendor\"],\n  },\n\n  AWAITING_RELEASE: {\n    RELEASED: [\"buyer\"],\n    DISPUTED: [\"vendor\"],\n  },\n\n  RELEASED: {},\n\n  REFUNDED: {},\n\n  EXPIRED: {},\n};\n\nexport function canTransitionEscrow(\n  escrow: IEscrow,\n  nextStatus: EscrowStatus,\n  actor: Actor,\n) {\n  const transitions = ESCROW_TRANSITIONS[escrow.status];\n  if (!transitions || !transitions[nextStatus]) {\n    throw new Error(\n      `Illegal escrow transition: ${escrow.status} ‚Üí ${nextStatus}`,\n    );\n  }\n\n  const allowedActors = transitions[nextStatus];\n  if (!allowedActors.includes(actor)) {\n    throw new Error(\n      `Actor ${actor} cannot perform ${escrow.status} ‚Üí ${nextStatus}`,\n    );\n  }\n}\n","import { Schema, model, Document } from \"mongoose\";\n\nexport interface IUser extends Document {\n  walletAddress: string;\n  sessionToken: ISessionToken;\n\n  // optional but useful\n  createdAt: Date;\n  updatedAt: Date;\n\n  // future-proofing\n  isBanned: boolean;\n}\n\nexport interface ISessionToken {\n  // tokenHash: string; future\n  tokenVersion: number;\n  createdAt: Date;\n}\n\nconst SessionTokenSchema = new Schema<ISessionToken>(\n  {\n    // tokenHash: { type: String, required: true, unique: true, default: null },\n    tokenVersion: { type: Number, default: 0 },\n  },\n  {\n    timestamps: true,\n  },\n);\n\nconst UserSchema = new Schema<IUser>(\n  {\n    walletAddress: {\n      type: String,\n      required: true,\n      unique: true,\n      index: true,\n      lowercase: true,\n      trim: true,\n    },\n    sessionToken: { type: SessionTokenSchema, default: () => ({}) },\n\n    isBanned: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  {\n    timestamps: true,\n  },\n);\n\nexport const User = model<IUser>(\"User\", UserSchema);\n","export const maxAgeMsForUnfundedEscrows = 20 * 60 * 1000; // 20 minutes\nexport const maxAgeMsForEscrowsNotAcked = 20 * 60 * 1000; // 20 minutes\n\nconst Settlement_Type = {\n  TEXT: \"TEXT\",\n  DOCUMENT: \"DOCUMENT\",\n};\n\nexport type SettlementType = keyof typeof Settlement_Type;\nexport default Settlement_Type;\n","import {\n  BadRequestError,\n  InternalServerError,\n} from \"../../errors/auth.erros.js\";\nimport { kaspaRpcService } from \"../../services/kaspaRpcService.js\";\nimport type { IEscrow } from \"../model/Escrow.js\";\n\nexport function getRefundableAmount(escrow: IEscrow): bigint {\n  return escrow.utxos\n    .filter((u) => !u.refunded)\n    .reduce((sum, u) => sum + BigInt(u.amount), 0n);\n}\n\nexport async function getAddressBalance(escrowAddress: string) {\n  if (!kaspaRpcService.isRpcConnected()) throw new InternalServerError();\n  if (typeof escrowAddress !== \"string\")\n    throw new BadRequestError(\"address must be a string\");\n\n  const balance = await kaspaRpcService.getBalancesByAddresses([escrowAddress]);\n  if (!balance) throw new BadRequestError(\"invalid address\");\n  return balance;\n}\n","import { kaspaRpcService } from \"../../services/kaspaRpcService.js\";\nimport { canTransitionEscrow } from \"../machine/escrow.fsm.js\";\nimport type { IEscrow } from \"../model/Escrow.js\";\nimport { decrypt } from \"../escrow.utils.js\";\nimport TR_STATUS from \"../../config/TR_STATUSES.js\";\nimport { getRefundableAmount } from \"./escrow.helpers.js\";\nimport {\n  PrivateKey,\n  createTransaction,\n  signTransaction,\n} from \"@kluster/kaspa-wasm-node\";\n\nexport async function executeRefund(escrow: IEscrow) {\n  canTransitionEscrow(escrow, TR_STATUS.REFUNDED, \"system\");\n  // idempotency guard\n  if (escrow.refundedAt) return;\n\n  const refundable = getRefundableAmount(escrow);\n  if (refundable === 0n) return;\n\n  const rpc = kaspaRpcService.getRpcClient();\n\n  const decryptedPrivateKey = await decrypt(escrow.encryptedPrivateKey);\n  const NETWORK = process.env.KASPA_NETWORK || \"testnet-10\";\n  const privateKey = new PrivateKey(decryptedPrivateKey);\n\n  const fromAddress = privateKey.toAddress(NETWORK).toString();\n  const utxoResponse = await rpc.getUtxosByAddresses([fromAddress]);\n  const utxos = utxoResponse.entries || [];\n\n  if (utxos.length === 0) {\n    throw new Error(\"Escrow balance unavailable\");\n  }\n\n  const priorityFee = 2_000n;\n\n  const totalInput = utxos.reduce((sum, utxo) => sum + BigInt(utxo.amount), 0n);\n\n  if (totalInput < refundable) {\n    throw new Error(\"Escrow balance insufficient for refund\");\n  }\n\n  const finalRefundableAmount =\n    refundable > priorityFee ? refundable - priorityFee : 0n;\n\n  if (finalRefundableAmount <= 0n) {\n    throw new Error(\"Escrow balance too low after fee\");\n  }\n\n  const tx = createTransaction(\n    utxos,\n    [\n      {\n        address: escrow.buyerAddress,\n        amount: finalRefundableAmount,\n      },\n    ],\n    priorityFee,\n  );\n\n  signTransaction(tx, [privateKey], true);\n  tx.finalize();\n\n  // üöÄ SUBMIT\n  const submitResult = await rpc.submitTransaction({\n    transaction: tx,\n  });\n\n  // ‚úÖ persist refund state\n  for (const utxo of escrow.utxos) {\n    if (utxo.refunded) continue;\n    utxo.refunded = true;\n    utxo.refundTxId = submitResult.transactionId;\n    utxo.refundedAt = new Date();\n  }\n  escrow.status = TR_STATUS.REFUNDED;\n  escrow.refundTxId = submitResult.transactionId;\n  escrow.refundedAt = new Date();\n  await escrow.save();\n}\n","import { kaspaRpcService } from \"../../services/kaspaRpcService.js\";\nimport TR_STATUS from \"../../config/TR_STATUSES.js\";\nimport {\n  PrivateKey,\n  createTransaction,\n  signTransaction,\n  kaspaToSompi,\n} from \"@kluster/kaspa-wasm-node\";\nimport { Actor, canTransitionEscrow } from \"../machine/escrow.fsm.js\";\nimport { decrypt } from \"../escrow.utils.js\";\nimport { IEscrow } from \"../model/Escrow.js\";\nimport { User } from \"../../auth/User.model.js\";\nimport { ISettlement } from \"../../settlement/model/Settlement.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { BadRequestError } from \"../../errors/auth.erros.js\";\n\nexport interface IFinalSettlement {\n  content?: string;\n  file?: { signedUrl: string; expiresIn: string };\n}\n\nexport async function executeRelease(escrow: IEscrow, senderId: string) {\n  const user = await User.findById(senderId);\n  const actor: Actor =\n    user?.walletAddress === escrow.buyerAddress ? \"buyer\" : \"vendor\";\n  canTransitionEscrow(escrow, TR_STATUS.RELEASED, actor);\n  console.log(\"here at top\", escrow, escrow.encryptedPrivateKey);\n  if (escrow.status === TR_STATUS.RELEASED) {\n    throw new Error(\"Escrow already released\");\n  }\n\n  console.log(\"here after transistion\");\n  if (\n    escrow.status !== TR_STATUS.FUNDED &&\n    escrow.status === TR_STATUS.PARTIALLY_FUNDED\n  ) {\n    throw new Error(\"Escrow not funded or partially funded\");\n  }\n\n  console.log(\"escrow funded properly\");\n\n  const rpc = kaspaRpcService.getRpcClient();\n\n  console.log(\"kaspa service\", rpc);\n\n  // load escrow private key\n  if (!escrow.encryptedPrivateKey) {\n    throw new Error(\"Escrow private key is missing\");\n  }\n  console.log(escrow.encryptedPrivateKey);\n  const decryptedPrivateKey = await decrypt(escrow.encryptedPrivateKey);\n  console.log(\"decrypted\", decryptedPrivateKey);\n\n  if (!decryptedPrivateKey) {\n    throw new Error(\"Failed to decrypt escrow private key\");\n  }\n  console.log(\"here at private\");\n  const privateKey = new PrivateKey(decryptedPrivateKey);\n  const NETWORK = process.env.KASPA_NETWORK || \"testnet-10\";\n\n  const fromAddress = privateKey.toAddress(NETWORK).toString();\n\n  // fetch UTXOs\n  const utxoResponse = await rpc.getUtxosByAddresses([fromAddress]);\n  const utxos = utxoResponse.entries || [];\n\n  if (utxos.length === 0) {\n    throw new Error(\"Escrow balance unavailable or already spent\");\n  }\n\n  console.log(\"utxos have length\");\n\n  const totalInput = utxos.reduce((sum, utxo) => sum + BigInt(utxo.amount), 0n);\n  if (\n    totalInput < BigInt(kaspaToSompi(escrow.expectedAmount.toString()) ?? 0n)\n  ) {\n    throw new Error(\"Escrow underfunded\");\n  }\n\n  const priorityFee = 2_000n;\n\n  const sendAmount = escrow.amount;\n\n  const sendAmountSompi = kaspaToSompi(sendAmount.toString()) ?? 0n;\n  if (totalInput < sendAmountSompi + priorityFee) {\n    throw new Error(\"Escrow underfunded for release + fee\");\n  }\n\n  const tx = createTransaction(\n    utxos,\n    [\n      {\n        address: escrow.vendorAddress,\n        amount: sendAmountSompi,\n      },\n    ],\n    priorityFee,\n  );\n\n  console.log(\"transaction created\");\n\n  // sign transaction\n  signTransaction(tx, [privateKey], true);\n\n  // Finalize\n  tx.finalize();\n\n  //üöÄ SUBMIT TO NETWORK\n  const submitResult = await rpc.submitTransaction({\n    transaction: tx,\n  });\n\n  escrow.status = TR_STATUS.RELEASED;\n  escrow.releaseTxId = submitResult.transactionId;\n  await escrow.save();\n\n  return submitResult.transactionId;\n}\n\nexport async function allowFundsRelease(\n  escrow: IEscrow,\n  actor: Actor,\n  settlement: ISettlement,\n  SettlementService: SettlementService,\n) {\n  const finalSettlement: IFinalSettlement = {};\n  if (settlement.type === \"TEXT\") {\n    const { text } = await SettlementService.decryptText(settlement, actor);\n    console.log(\"text decrypted\", text);\n    finalSettlement.content = text;\n  } else if (settlement.type === \"DOCUMENT\") {\n    const file = await SettlementService.signDownloadUrl(settlement, actor);\n    finalSettlement.file = file;\n    console.log(\"file\", file);\n  } else throw new BadRequestError(\"Invalid settlement type\");\n\n  if (escrow.status !== TR_STATUS.FUNDED) {\n    throw new BadRequestError(\"Escrow not ready for release\");\n  }\n\n  escrow.status = TR_STATUS.AWAITING_RELEASE;\n  await escrow.save();\n  return finalSettlement;\n}\n","import mongoose, { Schema, Document } from \"mongoose\";\nimport { type EscrowStatus } from \"../../config/TR_STATUSES.js\";\nimport TR_STATUS from \"../../config/TR_STATUSES.js\";\n\nexport interface IEscrow extends Document {\n  escrowId: string;\n  title: string;\n\n  // parties\n  buyerAddress: string;\n  vendorAddress: string;\n\n  // kaspa\n  escrowAddress: string;\n  encryptedPrivateKey: string; // NEVER plaintext\n\n  // amounts\n  amount: number;\n  expectedAmount: number;\n  fundedAmount: number;\n\n  // state\n  status: EscrowStatus;\n\n  // chain data\n  utxos: IEscrowUTXO[];\n  fundingTxIds: string[];\n  releaseTxId?: string;\n  refundTxId?: string;\n\n  // lifecycle\n  partiallyFundedAt?: Date;\n  fundedAt?: Date;\n  buyerReleasedAt?: Date;\n  vendorAcknowledgedAt?: Date;\n\n  expiresAt: number;\n  expiredAt: Date;\n  refundedAt?: Date;\n  releasedAt?: Date;\n\n  createdAt: Date;\n  updatedAt: Date;\n\n  __v: number;\n}\n\nexport interface IEscrowUTXO {\n  txId: string;\n  index: number;\n  amount: number; // sompi\n  address: string; // escrow address\n  confirmations: number;\n\n  refunded: boolean;\n  refundTxId?: string;\n  refundedAt?: Date;\n}\n\nexport interface CreateEscrowDTO {\n  title: string;\n  escrowId: string;\n  buyerAddress: string;\n  vendorAddress: string;\n  escrowAddress: string;\n  amount: number;\n  expectedAmount: number;\n  encryptedPrivateKey: string;\n  status: EscrowStatus;\n  expiresAt: number;\n}\n\nconst escrowSchema = new Schema<IEscrow>(\n  {\n    escrowId: { type: String, required: true, unique: true },\n    title: { type: String, required: true },\n\n    buyerAddress: { type: String, required: true, index: true },\n    vendorAddress: { type: String, required: true, index: true },\n\n    escrowAddress: { type: String, required: true, unique: true },\n    encryptedPrivateKey: { type: String, required: true },\n\n    amount: { type: Number, required: true },\n    expectedAmount: { type: Number, required: true },\n    fundedAmount: { type: Number, default: 0 },\n\n    status: {\n      type: String,\n      enum: Object.values(TR_STATUS),\n      required: true,\n      index: true,\n    },\n\n    utxos: [\n      {\n        txId: String,\n        index: Number,\n        amount: Number,\n        confirmations: Number,\n      },\n    ],\n\n    fundingTxIds: [{ type: String }],\n    releaseTxId: { type: String },\n    refundTxId: { type: String },\n    refundedAt: { type: Date },\n\n    partiallyFundedAt: { type: Date },\n    fundedAt: { type: Date },\n    buyerReleasedAt: { type: Date },\n    vendorAcknowledgedAt: { type: Date },\n    expiresAt: { type: Number, required: true, index: true },\n    expiredAt: { type: Date, index: true },\n    releasedAt: { type: Date },\n  },\n  { timestamps: true },\n);\n\n// escrowSchema.index({ expiresAt: 1 });\nescrowSchema.index({ buyerAddress: 1, status: 1 });\nescrowSchema.index({ vendorAddress: 1, status: 1 });\n\nexport const Escrow = mongoose.model<IEscrow>(\"Escrow\", escrowSchema);\n","import type { IEscrow, IEscrowUTXO } from \"../model/Escrow.js\";\nimport { kaspaToSompi, sompiToKaspaString } from \"@kluster/kaspa-wasm-node\";\nimport { canTransitionEscrow } from \"../machine/escrow.fsm.js\";\nimport TR_STATUS from \"../../config/TR_STATUSES.js\";\nimport { Escrow } from \"../model/Escrow.js\";\n\nexport async function executeFundingUpdate(\n  escrow: IEscrow,\n  utxos: IEscrowUTXO[],\n) {\n  const updateFields: Partial<IEscrow> = {};\n\n  /* ---------- balance calculation ---------- */\n  const balance = utxos.reduce((a, u) => a + BigInt(u.amount), 0n);\n  const requiredSompi = kaspaToSompi(escrow.expectedAmount.toString()) ?? 0n;\n\n  updateFields.fundedAmount = Number(sompiToKaspaString(balance));\n\n  /* ---------- merge UTXOs safely ---------- */\n  const existingUtxoKeys = new Set(\n    escrow.utxos.map((u) => `${u.txId}:${u.index}`),\n  );\n\n  const newUtxos = utxos.filter(\n    (u) => !existingUtxoKeys.has(`${u.txId}:${u.index}`),\n  );\n\n  if (newUtxos.length > 0) {\n    updateFields.utxos = [...escrow.utxos, ...newUtxos];\n  }\n\n  /* ---------- merge fundingTxIds safely ---------- */\n  const existingTxIds = new Set(escrow.fundingTxIds ?? []);\n  const newTxIds = newUtxos\n    .map((u) => u.txId)\n    .filter((txId) => !existingTxIds.has(txId));\n\n  if (newTxIds.length > 0) {\n    updateFields.fundingTxIds = [...(escrow.fundingTxIds ?? []), ...newTxIds];\n  }\n\n  /* ---------- FSM + status update ---------- */\n  if (balance < requiredSompi) {\n    canTransitionEscrow(escrow, TR_STATUS.PARTIALLY_FUNDED, \"system\");\n\n    updateFields.status = TR_STATUS.PARTIALLY_FUNDED;\n    updateFields.partiallyFundedAt = new Date();\n  } else {\n    canTransitionEscrow(escrow, TR_STATUS.FUNDED, \"system\");\n\n    updateFields.status = TR_STATUS.FUNDED;\n    updateFields.fundedAt = new Date();\n  }\n\n  /* ---------- atomic partial update ---------- */\n  await Escrow.findByIdAndUpdate(\n    escrow._id,\n    { $set: updateFields },\n    { new: false },\n  );\n\n  // TODO: emit websocket event\n}\n","import mongoose, { Schema, Document, Model } from \"mongoose\";\n\nexport interface ISubscription extends Document {\n  addresses: string[];\n}\n\ninterface ISubscriptionModel extends Model<ISubscription> {\n  addAddresses(newAddresses: string[]): Promise<ISubscription>;\n  getAddresses(): Promise<string[]>;\n}\n\nconst subscriptionSchema = new Schema<ISubscription>({\n  addresses: { type: [String], default: [] },\n});\n\n// Static method to add addresses\nsubscriptionSchema.statics.addAddresses = async function (\n  newAddresses: string[],\n) {\n  let sub = await this.findOne();\n  if (!sub) {\n    sub = await this.create({ addresses: [] });\n  }\n\n  // Avoid duplicates\n  sub.addresses = Array.from(new Set([...sub.addresses, ...newAddresses]));\n  await sub.save();\n  return sub;\n};\n\n// Static method to get all addresses\nsubscriptionSchema.statics.getAddresses = async function () {\n  const sub = await this.findOne();\n  return sub?.addresses || [];\n};\n\nexport const Subscription = mongoose.model<ISubscription, ISubscriptionModel>(\n  \"Subscription\",\n  subscriptionSchema,\n);\n","import { kaspaRpcService } from \"../../services/kaspaRpcService.js\";\n\nclass KaspaAddressListener {\n  private rpc: any | null = null;\n  private subscribedAddresses = new Set<string>();\n  private isSubscribed = false;\n\n  private getRpc() {\n    if (!this.rpc) {\n      this.rpc = kaspaRpcService.getRpcClient();\n    }\n    return this.rpc;\n  }\n\n  async init(initialAddresses: string[]) {\n    initialAddresses.forEach((a) => this.subscribedAddresses.add(a));\n    await this.resubscribe();\n  }\n\n  async addAddress(address: string) {\n    if (!address || this.subscribedAddresses.has(address)) return;\n\n    this.subscribedAddresses.add(address);\n    await this.resubscribe();\n  }\n\n  async addAddresses(addresses: string[]) {\n    let changed = false;\n    for (const addr of addresses) {\n      if (addr && !this.subscribedAddresses.has(addr)) {\n        this.subscribedAddresses.add(addr);\n        changed = true;\n      }\n    }\n\n    if (changed) await this.resubscribe();\n  }\n\n  private async resubscribe() {\n    // sanitize addresses\n    const addresses = Array.from(this.subscribedAddresses)\n      .map((a) => String(a).trim())\n      .filter((a) => a.length > 0);\n\n    if (addresses.length === 0) {\n      console.warn(\"‚ö†Ô∏è No valid addresses to subscribe\");\n      return;\n    }\n\n    console.log(\"üì° Subscribing to addresses:\", addresses);\n\n    const rpc = this.getRpc();\n\n    // unsubscribe first if already subscribed\n    if (this.isSubscribed) {\n      try {\n        await rpc.unsubscribeUtxosChanged();\n      } catch (err) {\n        console.warn(\"‚ö†Ô∏è Failed to unsubscribe before resubscribe:\", err);\n      }\n    }\n\n    // subscribe\n    try {\n      await rpc.subscribeUtxosChanged(addresses); // ‚ö†Ô∏è MUST wrap in object\n      this.isSubscribed = true;\n      console.log(\"‚úÖ Subscribed successfully:\", addresses.length);\n    } catch (err) {\n      console.error(\"‚ùå Failed to subscribe addresses:\", err, addresses);\n    }\n  }\n}\n\nexport const kaspaAddressListener = new KaspaAddressListener();\n","import crypto from \"crypto\";\nimport EscrowStore from \"../escrow.store.js\";\nimport { Escrow, IEscrowUTXO, type IEscrow } from \"../model/Escrow.js\";\nimport { PrivateKey } from \"@kluster/kaspa-wasm-node\";\nimport TR_STATUS from \"../../config/TR_STATUSES.js\";\nimport { encrypt } from \"../escrow.utils.js\";\nimport { escrowFeeBuffer } from \"../../utils/bufferCalculator.js\";\nimport { BadRequestError, NotFoundError } from \"../../errors/auth.erros.js\";\nimport { Actor, canTransitionEscrow } from \"../machine/escrow.fsm.js\";\nimport { User } from \"../../auth/User.model.js\";\nimport { checkExpiry } from \"../../utils/checkExpiry.js\";\nimport { maxAgeMsForUnfundedEscrows } from \"../../config/options.js\";\nimport * as Refund from \"./escrow.refund.js\";\nimport * as Release from \"./escrow.release.js\";\nimport * as Funding from \"./escrow.funding.js\";\nimport { kaspaRpcService } from \"../../services/kaspaRpcService.js\";\nimport { Subscription } from \"../model/Subscription.js\";\nimport { kaspaAddressListener } from \"./kaspaAddressListener.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { getAddressBalance } from \"./escrow.helpers.js\";\n// import { subscribeUtxosChangedForAddress } from \"../escrow.listener.js\";\n//\n\nexport interface ISettlementDataInput {\n  type: \"TEXT\" | \"DOCUMENT\";\n  content?: string;\n  file?: {\n    buffer: any;\n    mimeType: string;\n    filename: string;\n  };\n}\n\nexport default class EscrowService {\n  constructor(\n    private readonly escrowStore: EscrowStore,\n    private readonly SettlementService: SettlementService,\n  ) {}\n\n  async createEscrow(\n    title: string,\n    amount: number,\n    buyerAddress: string,\n    vendorAddress: string,\n  ): Promise<IEscrow> {\n    if (title.length < 3)\n      throw new BadRequestError(\"title should be greater that 3 chars\");\n    const ESCROW_FEE_BUFFER_KAS = escrowFeeBuffer; // small buffer for fees in KAS\n    const totalAmountKAS = amount + ESCROW_FEE_BUFFER_KAS;\n\n    const NETWORK = process.env.KASPA_NETWORK || \"testnet-10\";\n\n    const escrowId = crypto.randomUUID();\n\n    // 1Ô∏è‚É£ Generate 32-byte random private key (hex)\n    const privateKeyHex = crypto.randomBytes(32).toString(\"hex\");\n\n    // 2Ô∏è‚É£ Create Kaspa private key\n    const privateKey = new PrivateKey(privateKeyHex);\n\n    // 3Ô∏è‚É£ Derive escrow address\n    const escrowAddress = privateKey.toAddress(NETWORK).toString();\n\n    const encryptedPrivateKey = await encrypt(privateKeyHex);\n\n    const expiresAt = Date.now() + maxAgeMsForUnfundedEscrows;\n\n    const escrow = await this.escrowStore.create({\n      escrowId,\n      title,\n      buyerAddress,\n      vendorAddress,\n      escrowAddress,\n      amount,\n      expectedAmount: totalAmountKAS, // KAS\n      encryptedPrivateKey,\n      status: TR_STATUS.CREATED,\n      expiresAt,\n    });\n\n    await Subscription.updateOne(\n      {},\n      { $addToSet: { addresses: escrowAddress } },\n      { upsert: true },\n    );\n\n    await kaspaAddressListener.addAddress(escrowAddress);\n\n    console.log(`üì° Subscribed to UTXOs for escrow ${escrow.escrowId}`);\n\n    return escrow;\n  }\n\n  //\n  // vendor creates settlement and acknowledges\n  async createSettlement(\n    escrowId: string,\n    senderId: string,\n    settlementData: ISettlementDataInput,\n  ) {\n    const { escrow, actor } = await this.getEscrowAndActor(escrowId, senderId);\n\n    canTransitionEscrow(escrow, TR_STATUS.AWAITING_PAYMENT, actor);\n    const input = {\n      escrow: escrow._id.toString(),\n      ...settlementData,\n    };\n    console.log(\"transition valid\");\n    const settlement = await this.SettlementService.create(input);\n    console.log(\"settlement created successfully\");\n    escrow.status = TR_STATUS.AWAITING_PAYMENT;\n    escrow.vendorAcknowledgedAt = new Date();\n\n    await escrow.save();\n    return settlement;\n  }\n\n  // buyer decrypts settlement and change state to awaiting release to signal funds release is next\n  async allowRelease(\n    escrowId: string,\n    senderId: string,\n  ): Promise<Release.IFinalSettlement> {\n    const { escrow, actor } = await this.getEscrowAndActor(escrowId, senderId);\n    console.log(\"here1\", actor, escrow.status);\n    canTransitionEscrow(escrow, TR_STATUS.AWAITING_RELEASE, actor);\n    console.log(\"transition valid\");\n    const settlement = await this.SettlementService.getSettlmentByEscrow(\n      escrow._id.toString(),\n    );\n    console.log(\"settlement found\", settlement);\n    return Release.allowFundsRelease(\n      escrow,\n      actor,\n      settlement,\n      this.SettlementService,\n    );\n  }\n\n  // refund buyer using saved address\n  private async refundBuyer(escrow: IEscrow) {\n    return Refund.executeRefund(escrow);\n  }\n\n  // inner helper\n  private async getEscrowAndActor(escrowId: string, senderId: string) {\n    const escrow = await this.getEscrowById(escrowId);\n    if (!escrow) throw new NotFoundError(\"Escrow not found\");\n\n    const sender = await User.findOne({ _id: senderId });\n    if (!sender)\n      throw new NotFoundError(\"Address is not linked to any account\");\n    const actor: Actor =\n      sender.walletAddress === escrow.vendorAddress ? \"vendor\" : \"buyer\";\n    return { escrow, actor };\n  }\n\n  // funding update for listener\n  async applyFundingUpdate(escrow: IEscrow, utxos: IEscrowUTXO[]) {\n    return Funding.executeFundingUpdate(escrow, utxos);\n  }\n\n  // refunding partially funded escrows that are expired\n  async handlePartialRefundAndExpiry(escrow: IEscrow) {\n    canTransitionEscrow(escrow, TR_STATUS.EXPIRED, \"system\");\n\n    await this.refundBuyer(escrow);\n    escrow.status = TR_STATUS.EXPIRED;\n    escrow.expiredAt = new Date();\n\n    await escrow.save();\n  }\n\n  // gets pending escrows from cron and checks for expiry;\n  async handlePossibleExpiry(escrow: IEscrow) {\n    console.log(\"here1\");\n\n    const now = Date.now();\n    const isExpired = now >= escrow.expiresAt;\n\n    console.log(\"here2\", isExpired, {\n      now,\n      expiresAt: escrow.expiresAt,\n    });\n\n    console.log(\"here2\", isExpired);\n    if (!isExpired) return;\n    switch (escrow.status) {\n      case TR_STATUS.CREATED:\n      case TR_STATUS.AWAITING_PAYMENT: {\n        // awaiting payment state is not handled\n        canTransitionEscrow(escrow, TR_STATUS.EXPIRED, \"system\");\n\n        escrow.status = TR_STATUS.EXPIRED;\n        escrow.expiredAt = new Date(now);\n        break;\n      }\n\n      case TR_STATUS.PARTIALLY_FUNDED: {\n        await this.handlePartialRefundAndExpiry(escrow);\n        break;\n      }\n    }\n\n    await escrow.save();\n  }\n\n  async getEscrowByAddress(escrowAddress: string): Promise<IEscrow | null> {\n    return this.escrowStore.getByAddress(escrowAddress);\n  }\n\n  async getEscrowsByAddress(userAddress: string): Promise<IEscrow[]> {\n    return this.escrowStore.getEscrowsByAddress(userAddress);\n  }\n\n  async getEscrowBalance(escrowAddress: string) {\n    return getAddressBalance(escrowAddress);\n  }\n\n  async getEscrowById(escrowId: string): Promise<IEscrow | null> {\n    return this.escrowStore.getById(escrowId);\n  }\n\n  async getPendingEscrows() {\n    return this.escrowStore.getPendingEscrows();\n  }\n\n  async getUsersPendingEscrows(address: string) {\n    return this.escrowStore.getUserPendingEscrows(address);\n  }\n\n  async getUnackedEscrows(address: string) {\n    return this.escrowStore.getUnackedEscrows(address);\n  }\n\n  async getDashboardStats(address: string) {\n    const activeEscrows = (await this.escrowStore.getPendingEscrows()).length;\n    const completedEscrows = (\n      await this.escrowStore.getUserCompletedEscrows(address)\n    ).length;\n    const unackedEscrows = (await this.getUnackedEscrows(address)).length;\n    const recentEscrows = await this.escrowStore.getUserRecentEscrows(address);\n    const totalReceived = await this.escrowStore.getUserTotalReceived(address);\n\n    return {\n      activeEscrows,\n      completedEscrows,\n      unackedEscrows,\n      recentEscrows,\n      totalReceived,\n    };\n  }\n\n  async releaseEscrowFunds(escrowId: string, senderId: string) {\n    const escrow = await this.escrowStore.getById(escrowId);\n    if (!escrow) {\n      throw new Error(\"Escrow not found\");\n    }\n    return Release.executeRelease(escrow, senderId);\n  }\n}\n","import { Escrow } from \"./model/Escrow.js\";\nimport type { IEscrow, CreateEscrowDTO } from \"./model/Escrow.js\";\nimport type { EscrowStatus } from \"../config/TR_STATUSES.js\";\n\nexport default class EscrowStore {\n  async create(data: CreateEscrowDTO): Promise<IEscrow> {\n    const escrow = await Escrow.create(data);\n    return escrow;\n  }\n\n  async getById(escrowId: string): Promise<IEscrow | null> {\n    return Escrow.findOne({ escrowId });\n  }\n\n  async getByAddress(escrowAddress: string): Promise<IEscrow | null> {\n    return Escrow.findOne({ escrowAddress });\n  }\n\n  async getEscrowsByAddress(userAddress: string): Promise<IEscrow[]> {\n    const normalized = userAddress.toLowerCase();\n\n    return Escrow.find({\n      $or: [{ buyerAddress: normalized }, { vendorAddress: normalized }],\n    }).sort({ createdAt: -1 });\n  }\n\n  async getPendingEscrows(): Promise<IEscrow[]> {\n    return Escrow.find({\n      status: { $in: [\"CREATED\", \"AWAITING_PAYMENT\", \"PARTIALLY_FUNDED\"] },\n    });\n  }\n\n  async getUserCompletedEscrows(address: string): Promise<IEscrow[]> {\n    return Escrow.find({\n      status: \"RELEASED\",\n      $or: [{ buyerAddress: address }, { vendorAddress: address }],\n    });\n  }\n\n  async getUserPendingEscrows(address: string): Promise<IEscrow[]> {\n    return Escrow.find({\n      status: {\n        $in: [\n          \"CREATED\",\n          \"AWAITING_PAYMENT\",\n          \"PARTIALLY_FUNDED\",\n          \"FUNDED\",\n          \"AWAITING_RELEASE\",\n        ],\n      },\n      $or: [{ buyerAddress: address }, { vendorAddress: address }],\n    });\n  }\n\n  async getUnackedEscrows(address: string): Promise<IEscrow[]> {\n    return Escrow.find({\n      status: \"CREATED\", // Since you're only checking one status, you can skip $in\n      vendorAddress: address,\n    });\n  }\n\n  async getUserRecentEscrows(address: string): Promise<IEscrow[]> {\n    return Escrow.find({\n      $or: [{ buyerAddress: address }, { vendorAddress: address }],\n    })\n      .sort({ createdAt: -1 })\n      .limit(3);\n  }\n\n  async getUserTotalReceived(address: string): Promise<number> {\n    const result = await Escrow.aggregate([\n      {\n        $match: {\n          vendorAddress: address,\n          status: \"RELEASED\",\n        },\n      },\n      {\n        $group: {\n          _id: null,\n          totalReceived: { $sum: \"$amount\" },\n        },\n      },\n    ]);\n\n    return result[0]?.totalReceived || 0;\n  }\n\n  // async updateStatus(\n  //   escrowId: string,\n  //   status: EscrowStatus,\n  //   txid?: string,\n  // ): Promise<IEscrow | null> {\n  //   return Escrow.findOneAndUpdate(\n  //     { escrowId },\n  //     { status, fundingTxId: txid },\n  //     { new: true },\n  //   );\n  // }\n\n  // escrow.store.ts\n  async expireOldEscrows(olderThanMs: number) {\n    const cutoff = new Date(Date.now() - olderThanMs);\n\n    return Escrow.updateMany(\n      {\n        status: \"AWAITING_PAYMENT\",\n        createdAt: { $lt: cutoff },\n      },\n      { status: \"EXPIRED\" },\n    );\n  }\n}\n","import AppError from \"../errors/AppError.js\";\nimport type { Response } from \"express\";\n\nexport const catchError = (res: Response, error: any) => {\n  return res\n    .status(\n      error instanceof AppError && \"statusCode\" in error\n        ? error.statusCode\n        : 500,\n    )\n    .json({\n      success: false,\n      message:\n        error instanceof AppError ? error.message : \"Internal server error\",\n      error,\n    });\n};\n","import z from \"zod\";\nimport Settlement_Type from \"../config/options.js\";\n\nexport const createSettlementSchema = z.object({\n  escrow: z.string(),\n  type: z.enum([\"TEXT\", \"DOCUMENT\"]),\n\n  // TEXT settlement\n  content: z.string().optional(),\n\n  // DOCUMENT settlement (validated in service)\n  file: z\n    .object({\n      buffer: z.any(), // Buffer validated at runtime\n      mimeType: z.string(),\n      filename: z.string(),\n    })\n    .optional(),\n});\n\nexport type createSettlementInput = z.infer<typeof createSettlementSchema>;\n","import {\n  BadRequestError,\n  NotFoundError,\n  UnauthorizedError,\n} from \"../errors/auth.erros.js\";\nimport { createSettlementInput, createSettlementSchema } from \"../utils/zod.js\";\nimport { SettlementStore } from \"./settlement.store.js\";\nimport { FileStorageService } from \"./files/fileStore.service.js\";\nimport Settlement_Type from \"../config/options.js\";\nimport { decrypt, encrypt } from \"../escrow/escrow.utils.js\";\nimport { Actor } from \"../escrow/machine/escrow.fsm.js\";\nimport { ISettlement } from \"./model/Settlement.js\";\n\nexport class SettlementService {\n  constructor(\n    private readonly settlementStore: SettlementStore,\n    private readonly fileStore: FileStorageService,\n  ) {}\n\n  async create(input: createSettlementInput) {\n    const validInput = createSettlementSchema.safeParse(input);\n    if (!validInput.success) {\n      throw new BadRequestError(\"Invalid settlement data\");\n    }\n\n    console.log(\"valid input success\", input.type);\n\n    const settlementData: Record<string, any> = {};\n\n    if (input.type === Settlement_Type.TEXT) {\n      if (!input.content) {\n        throw new BadRequestError(\n          \"Settlement of type 'TEXT' must have content\",\n        );\n      }\n\n      settlementData.content = await encrypt(input.content);\n    }\n\n    if (input.type === Settlement_Type.DOCUMENT) {\n      if (!input.file) {\n        throw new BadRequestError(\n          \"Settlement of type 'DOCUMENT' must include a file\",\n        );\n      }\n\n      settlementData.fileUrl = await this.fileStore.uploadPrivateFile({\n        buffer: input.file.buffer,\n        mimeType: input.file.mimeType,\n        filename: input.file.filename,\n      });\n    }\n\n    const final = {\n      escrow: input.escrow,\n      type: input.type,\n      ...settlementData,\n    };\n\n    console.log(\"final settlement data\", final);\n\n    return this.settlementStore.create(final);\n  }\n\n  async getSettlmentByEscrow(_id: string) {\n    const settlement = await this.settlementStore.getByEscrow(_id);\n    if (!settlement) throw new NotFoundError(\"settlement was not found\");\n    return settlement;\n  }\n\n  async signDownloadUrl(settlement: ISettlement, actor: Actor) {\n    if (actor !== \"buyer\") throw new UnauthorizedError();\n    if (settlement.type === \"TEXT\")\n      throw new BadRequestError(\"Cannot sign url for file of type 'TEXT'\");\n    const fileKey = settlement.fileUrl;\n    if (!fileKey) throw new BadRequestError(\"file was not found\");\n    const { signedUrl, expiresIn } =\n      await this.fileStore.signDownloadUrl(fileKey);\n\n    return { signedUrl, expiresIn };\n  }\n\n  async decryptText(settlement: ISettlement, actor: Actor) {\n    if (actor !== \"buyer\") throw new UnauthorizedError();\n    if (settlement.type === \"DOCUMENT\")\n      throw new BadRequestError(\"Cannot decrypt for file of type 'DOCUMENT'\");\n    const payload = settlement.content;\n    if (!payload) throw new BadRequestError(\"file was not found\");\n    const decrypted = await decrypt(payload);\n    return { text: decrypted };\n  }\n}\n","import mongoose, { Document, Types, Schema } from \"mongoose\";\nexport type SettlementType = \"TEXT\" | \"DOCUMENT\";\n\nexport interface ISettlement extends Document {\n  escrow: Types.ObjectId;\n  type: SettlementType;\n  content?: string; // for text\n  // for documents\n  fileUrl?: string;\n  fileName?: string;\n  mimeType?: string;\n  // lifecycle\n  providedAt: Date;\n  acceptedAt: Date;\n}\n\nexport type CreateSettlementDTO = {\n  escrow: string;\n  type: \"TEXT\" | \"DOCUMENT\";\n\n  content?: string;\n\n  file?: {\n    buffer: any;\n    mimeType: string;\n    filename: string;\n  };\n  fileUrl?: string;\n  mimeType?: string;\n};\n\nconst settlementSchema = new Schema<ISettlement>(\n  {\n    escrow: {\n      type: Schema.Types.ObjectId,\n      ref: \"Escrow\",\n      required: true,\n      index: true,\n    },\n    type: { type: String, enum: [\"TEXT\", \"DOCUMENT\"] },\n    // TEXT delivery\n    content: {\n      type: String,\n    },\n\n    // DOCUMENT delivery\n    fileUrl: {\n      type: String,\n    },\n    mimeType: {\n      type: String,\n      enum: [\n        \"application/pdf\",\n        \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n      ],\n    },\n\n    providedAt: {\n      type: Date,\n      default: Date.now,\n    },\n\n    acceptedAt: {\n      type: Date,\n    },\n  },\n  { timestamps: true },\n);\n\n// settlementSchema.pre(\"save\", function (this: ISettlement, next: any) {\n//   if (this.type === \"TEXT\" && !this.content) {\n//     return next(new Error(\"TEXT settlement requires content\"));\n//   }\n\n//   if (this.type === \"DOCUMENT\" && !this.fileUrl) {\n//     return next(new Error(\"DOCUMENT settlement requires fileUrl\"));\n//   }\n\n//   next();\n// });\n\nexport const Settlement = mongoose.model<ISettlement>(\n  \"Settlement\",\n  settlementSchema,\n);\n","import {\n  Settlement,\n  type CreateSettlementDTO,\n  type ISettlement,\n} from \"./model/Settlement.js\";\n\nexport class SettlementStore {\n  async create(data: CreateSettlementDTO): Promise<ISettlement> {\n    return Settlement.create(data);\n  }\n\n  async getById(id: string): Promise<ISettlement | null> {\n    return Settlement.findById(id).exec();\n  }\n\n  async getByEscrow(escrowId: string): Promise<ISettlement | null> {\n    return Settlement.findOne({ escrow: escrowId }).exec();\n  }\n\n  async update(\n    id: string,\n    data: Partial<CreateSettlementDTO>,\n  ): Promise<ISettlement | null> {\n    return Settlement.findOneAndUpdate({ _id: id }, data, {\n      new: true, // return updated doc\n      runValidators: true, // run schema validation + pre hooks\n    }).exec();\n  }\n\n  async accept(id: string): Promise<ISettlement | null> {\n    return Settlement.findByIdAndUpdate(\n      id,\n      { acceptedAt: new Date() },\n      { new: true },\n    ).exec();\n  }\n}\n","// services/FileStorageService.ts\nimport { createClient } from \"@supabase/supabase-js\";\nimport crypto from \"crypto\";\n\ninterface IUpload {\n  buffer: Buffer;\n  mimeType: string;\n  filename: string;\n}\n\nexport class FileStorageService {\n  private supabase;\n  private bucket: string;\n\n  constructor() {\n    this.bucket = process.env.SUPABASE_BUCKET!;\n    this.supabase = createClient(\n      process.env.SUPABASE_URL!,\n      process.env.SUPABASE_SERVICE_ROLE_KEY!,\n    );\n  }\n\n  async uploadPrivateFile(data: IUpload): Promise<string> {\n    const { buffer, mimeType, filename } = data;\n    const fileKey = crypto.randomUUID();\n    const objectPath = `${fileKey}/${filename}`;\n\n    const { error } = await this.supabase.storage\n      .from(this.bucket)\n      .upload(objectPath, buffer, {\n        contentType: mimeType,\n        upsert: false,\n      });\n\n    if (error) throw error;\n\n    return objectPath; // store this in DB\n  }\n\n  async signDownloadUrl(\n    fileKey: string,\n  ): Promise<{ signedUrl: string; expiresIn: string }> {\n    const ttl = 10;\n    const { data, error } = await this.supabase.storage\n      .from(this.bucket)\n      .createSignedUrl(fileKey, 60 * ttl); // 10 minutes\n\n    if (error) throw error;\n\n    return { signedUrl: data.signedUrl, expiresIn: `${ttl} minutes` };\n  }\n}\n","import type { Response } from \"express\";\nimport type { AuthRequest } from \"../../middleware/requireAuth.js\";\nimport EscrowService from \"../services/escrow.service.js\";\nimport EscrowStore from \"../escrow.store.js\";\nimport { catchError } from \"../../utils/catchError.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { SettlementStore } from \"../../settlement/settlement.store.js\";\nimport { FileStorageService } from \"../../settlement/files/fileStore.service.js\";\n\nconst Settlement = new SettlementService(\n  new SettlementStore(),\n  new FileStorageService(),\n);\nconst Escrow = new EscrowService(new EscrowStore(), Settlement);\n\nexport const createEscrow = async (req: AuthRequest, res: Response) => {\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n\n    const { title, amount, vendorAddress } = req.body;\n    if (!title || !amount || !vendorAddress) {\n      return res\n        .status(400)\n        .json({ error: \"title, amount and vendorAddress required\" });\n    }\n    const buyerAddress = user.wallet;\n\n    if (typeof title !== \"string\")\n      return res.status(400).json({\n        success: false,\n        message: \"Invalid type. title should be a string\",\n      });\n\n    if (typeof buyerAddress !== \"string\" || typeof vendorAddress !== \"string\")\n      return res.status(400).json({\n        success: false,\n        message: \"Invalid type. addresses should be strings\",\n      });\n\n    const escrow = await Escrow.createEscrow(\n      title,\n      Number(amount),\n      buyerAddress,\n      vendorAddress,\n    );\n    res.json({ success: true, escrow });\n  } catch (error) {\n    catchError(res, error);\n  }\n};\n","import type { Response } from \"express\";\nimport type { AuthRequest } from \"../../middleware/requireAuth.js\";\nimport EscrowService from \"../services/escrow.service.js\";\nimport EscrowStore from \"../escrow.store.js\";\nimport { catchError } from \"../../utils/catchError.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { SettlementStore } from \"../../settlement/settlement.store.js\";\nimport { FileStorageService } from \"../../settlement/files/fileStore.service.js\";\n\nconst Settlement = new SettlementService(\n  new SettlementStore(),\n  new FileStorageService(),\n);\nconst Escrow = new EscrowService(new EscrowStore(), Settlement);\n\nexport const getEscrowStatus = async (req: AuthRequest, res: Response) => {\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n    const { id } = req.params;\n\n    if (!id || typeof id !== \"string\") {\n      return res.status(400).json({ error: \"Invalid escrow ID\" });\n    }\n\n    const escrow = await Escrow.getEscrowById(id);\n\n    if (!escrow) {\n      return res.status(404).json({ error: \"Escrow not found\" });\n    }\n\n    res.json({ status: escrow.status });\n  } catch (error) {\n    catchError(res, error);\n  }\n};\n","import type { Response } from \"express\";\nimport type { AuthRequest } from \"../../middleware/requireAuth.js\";\nimport EscrowService from \"../services/escrow.service.js\";\nimport EscrowStore from \"../escrow.store.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { SettlementStore } from \"../../settlement/settlement.store.js\";\nimport { FileStorageService } from \"../../settlement/files/fileStore.service.js\";\n\nconst Settlement = new SettlementService(\n  new SettlementStore(),\n  new FileStorageService(),\n);\nconst Escrow = new EscrowService(new EscrowStore(), Settlement);\n\nexport const releaseEscrowFunds = async (req: AuthRequest, res: Response) => {\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n    const { id } = req.params;\n    if (!id || typeof id !== \"string\") {\n      return res.status(400).json({ error: \"Invalid escrow ID\" });\n    }\n\n    const txId = await Escrow.releaseEscrowFunds(id, user.id);\n    res.json({ success: true, txId });\n  } catch (err: any) {\n    res.status(400).json({ error: err.message });\n  }\n};\n","import type { Response } from \"express\";\nimport type { AuthRequest } from \"../../middleware/requireAuth.js\";\nimport EscrowService from \"../services/escrow.service.js\";\nimport EscrowStore from \"../escrow.store.js\";\nimport { catchError } from \"../../utils/catchError.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { SettlementStore } from \"../../settlement/settlement.store.js\";\nimport { FileStorageService } from \"../../settlement/files/fileStore.service.js\";\nimport TR_STATUS from \"../../config/TR_STATUSES.js\";\nimport Settlement_Type from \"../../config/options.js\";\nimport { ISettlementDataInput } from \"../services/escrow.service.js\";\n\nconst Settlement = new SettlementService(\n  new SettlementStore(),\n  new FileStorageService(),\n);\nconst Escrow = new EscrowService(new EscrowStore(), Settlement);\n\nexport async function acknowledgeEscrow(req: AuthRequest, res: Response) {\n  try {\n    const user = req.user;\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized\",\n      });\n    }\n\n    console.log(\"here, user auth successful\");\n\n    const { escrowId } = req.params;\n    if (!escrowId) {\n      return res.status(400).json({\n        success: false,\n        message: \"Escrow id is required\",\n      });\n    }\n\n    console.log(\"here, escrow id is valid\");\n\n    if (typeof escrowId !== \"string\" || escrowId.trim().length === 0) {\n      return res.status(400).json({\n        success: false,\n        message: \"Escrow id must be a non-empty string\",\n      });\n    }\n\n    console.log(\"here, escrow id is valid\");\n\n    const { type, content } = req.body;\n\n    console.log(\"here, type and content are \", type, content);\n\n    const settlementInput: ISettlementDataInput = {\n      type,\n      content,\n      file: req.file\n        ? {\n            buffer: req.file.buffer,\n            mimeType: req.file.mimetype,\n            filename: req.file.originalname,\n          }\n        : undefined,\n    };\n\n    const settlement = await Escrow.createSettlement(\n      escrowId,\n      user.id,\n      settlementInput,\n    );\n\n    console.log(\"here, settlement is created successfully\", settlement);\n\n    return res.status(200).json({\n      success: true,\n      message: \"Escrow acknowledged successfully\",\n      data: settlement,\n    });\n  } catch (error) {\n    catchError(res, error);\n  }\n}\n","import type { Response } from \"express\";\nimport EscrowService from \"../services/escrow.service.js\";\nimport EscrowStore from \"../escrow.store.js\";\nimport { catchError } from \"../../utils/catchError.js\";\nimport type { AuthRequest } from \"../../middleware/requireAuth.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { SettlementStore } from \"../../settlement/settlement.store.js\";\nimport { FileStorageService } from \"../../settlement/files/fileStore.service.js\";\n\nconst Settlement = new SettlementService(\n  new SettlementStore(),\n  new FileStorageService(),\n);\nconst Escrow = new EscrowService(new EscrowStore(), Settlement);\nexport async function allowFundsRelease(req: AuthRequest, res: Response) {\n  console.log(\"here1\");\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n    console.log(\"user available\");\n\n    const senderId = user.id;\n\n    const { escrowId } = req.params;\n    if (!escrowId || !senderId)\n      return res.status(400).json({\n        success: false,\n        message: \"escrow id and sender id are required\",\n      });\n\n    if (typeof escrowId !== \"string\" || typeof senderId !== \"string\")\n      return res.status(400).json({\n        success: false,\n        message: \"escrow id and sender id should be of type 'string'\",\n      });\n\n    console.log(\"escrow id and sender id available\");\n\n    const settlement = await Escrow.allowRelease(escrowId, senderId);\n    res.status(200).json({\n      success: true,\n      messsage:\n        \"Settlement verified and escrow funds now available for release\",\n      settlement,\n    });\n  } catch (error) {\n    catchError(res, error);\n  }\n}\n","import jwt, { JwtPayload } from \"jsonwebtoken\";\n\ninterface SessionTokenPayload {\n  sub: string;\n  wallet: string;\n  v: number;\n  iat: Date | number;\n}\n\nconst sessionSecret = process.env.SESSION_TOKEN_SECRET!;\nconst expiresIn = +process.env.SESSION_EXPIRES_IN!;\n\nexport function signSessionToken(payload: SessionTokenPayload): string {\n  return jwt.sign(payload, sessionSecret, {\n    expiresIn,\n  });\n}\n\nexport function verifySessionToken(token: string): SessionTokenPayload {\n  const payload = jwt.verify(token, sessionSecret) as JwtPayload;\n  return payload as unknown as SessionTokenPayload;\n}\n","import type { Request, Response, NextFunction } from \"express\";\nimport { User } from \"../auth/User.model.js\";\nimport { verifySessionToken } from \"../utils/jwt.js\";\n\nexport interface AuthRequest extends Request {\n  user?: {\n    id: string;\n    wallet: string;\n  };\n}\n\nexport async function requireAuth(\n  req: AuthRequest,\n  res: Response,\n  next: NextFunction,\n) {\n  try {\n    const cookieName = process.env.COOKIE_NAME!;\n    const sessionToken = req.cookies?.[cookieName];\n\n    if (!sessionToken) {\n      return res.status(401).json({ message: \"Unauthenticated\" });\n    }\n\n    const payload = verifySessionToken(sessionToken);\n\n    const user = await User.findById(payload.sub);\n\n    if (!user) {\n      return res.status(401).json({ message: \"Invalid session\" });\n    }\n\n    if (user.isBanned) {\n      return res.status(403).json({ message: \"User is banned\" });\n    }\n\n    if (user.sessionToken.tokenVersion !== payload.v) {\n      return res.status(401).json({ message: \"Session revoked\" });\n    }\n\n    req.user = {\n      id: user.id,\n      wallet: user.walletAddress,\n    };\n\n    next();\n  } catch {\n    return res.status(401).json({ message: \"Invalid or expired session\" });\n  }\n}\n","import type { Response } from \"express\";\nimport type { AuthRequest } from \"../../middleware/requireAuth.js\";\nimport EscrowService from \"../services/escrow.service.js\";\nimport EscrowStore from \"../escrow.store.js\";\nimport { catchError } from \"../../utils/catchError.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { SettlementStore } from \"../../settlement/settlement.store.js\";\nimport { FileStorageService } from \"../../settlement/files/fileStore.service.js\";\n\nconst Settlement = new SettlementService(\n  new SettlementStore(),\n  new FileStorageService(),\n);\nconst Escrow = new EscrowService(new EscrowStore(), Settlement);\n\nexport async function getUserEscrows(req: AuthRequest, res: Response) {\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n\n    const escrows = await Escrow.getEscrowsByAddress(user.wallet);\n    return res.status(200).json({\n      success: true,\n      message: \"escrows fetched successfully\",\n      escrows,\n    });\n  } catch (error) {\n    catchError(res, error);\n  }\n}\n\nexport async function getSingleEscrow(req: AuthRequest, res: Response) {\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n    const { escrowId } = req.params;\n    if (!escrowId || typeof escrowId !== \"string\") {\n      return res.status(400).json({ error: \"Invalid escrow ID\" });\n    }\n\n    const escrow = await Escrow.getEscrowById(escrowId);\n    if (!escrow)\n      return res\n        .status(404)\n        .json({ success: false, message: \"escrow not found\", escrow });\n\n    return res.status(200).json({\n      success: true,\n      message: \"escrow retrieved successfully\",\n      escrow,\n    });\n  } catch (error) {\n    catchError(res, error);\n  }\n}\n\nexport async function getUnackedEscrows(req: AuthRequest, res: Response) {\n  console.log(\"getUnackedEscrows\");\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n\n    const escrows = await Escrow.getUnackedEscrows(user.wallet);\n    console.log(escrows);\n\n    return res.status(200).json({\n      success: true,\n      message: \"escrow retrieved successfully\",\n      escrows,\n    });\n  } catch (error) {\n    catchError(res, error);\n  }\n}\n","import type { Request, Response, NextFunction } from \"express\";\nimport multer from \"multer\";\n\nconst upload = multer({\n  storage: multer.memoryStorage(),\n  limits: {\n    fileSize: 10 * 1024 * 1024, // 10MB\n  },\n}).single(\"file\"); // field name from client\n\nexport function createBuffer(req: Request, res: Response, next: NextFunction) {\n  upload(req, res, (err) => {\n    if (err) {\n      return res.status(400).json({\n        success: false,\n        message: err.message,\n      });\n    }\n\n    // Now req.body and req.file are populated\n    const { type } = req.body;\n\n    if (!type) {\n      return res.status(400).json({\n        success: false,\n        message: \"Type is required\",\n      });\n    }\n\n    if (type === \"DOCUMENT\" && !req.file) {\n      return res.status(400).json({\n        success: false,\n        message: \"File is required for DOCUMENT settlement\",\n      });\n    }\n\n    next();\n  });\n}\n","import type { Response } from \"express\";\nimport type { AuthRequest } from \"../../middleware/requireAuth.js\";\nimport EscrowService from \"../services/escrow.service.js\";\nimport EscrowStore from \"../escrow.store.js\";\nimport { catchError } from \"../../utils/catchError.js\";\nimport { SettlementService } from \"../../settlement/settlement.service.js\";\nimport { SettlementStore } from \"../../settlement/settlement.store.js\";\nimport { FileStorageService } from \"../../settlement/files/fileStore.service.js\";\n\nconst Settlement = new SettlementService(\n  new SettlementStore(),\n  new FileStorageService(),\n);\nconst Escrow = new EscrowService(new EscrowStore(), Settlement);\n\nexport const getDashboardStats = async (req: AuthRequest, res: Response) => {\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n\n    const stats = await Escrow.getDashboardStats(user.wallet);\n\n    if (!stats) {\n      return res.status(404).json({\n        success: false,\n        message: \"No stats found\",\n      });\n    }\n\n    return res.status(200).json({\n      success: true,\n      message: \"Dashboard stats fetched successfully\",\n      stats,\n    });\n  } catch (error) {\n    catchError(res, error);\n  }\n};\n","import { Router } from \"express\";\nimport type { Request, Response } from \"express\";\nimport { kaspaRpcService } from \"../services/kaspaRpcService.js\";\nimport { createEscrow } from \"../escrow/controllers/createEscrow.js\";\nimport { getEscrowStatus } from \"../escrow/controllers/getEscrowStatus.js\";\nimport { releaseEscrowFunds } from \"../escrow/controllers/releaseEscrow.js\";\nimport { acknowledgeEscrow } from \"../escrow/controllers/vendorAck.js\";\nimport { allowFundsRelease } from \"../escrow/controllers/allowRelease.js\";\nimport { requireAuth } from \"../middleware/requireAuth.js\";\nimport {\n  getSingleEscrow,\n  getUnackedEscrows,\n  getUserEscrows,\n} from \"../escrow/controllers/getUserEscrows.js\";\nimport { createBuffer } from \"../middleware/upload.js\";\nimport { getDashboardStats } from \"../escrow/controllers/dashboard.controller.js\";\n\nconst router: Router = Router();\n\nrouter.post(\"/create\", requireAuth, createEscrow);\n\nrouter.post(\n  \"/:escrowId/settlement/ack\",\n  requireAuth,\n  createBuffer,\n  acknowledgeEscrow,\n);\n\nrouter.get(\"/dashboard\", requireAuth, getDashboardStats);\n\nrouter.get(\"/:id/status\", requireAuth, getEscrowStatus);\n\nrouter.post(\"/:escrowId/allow\", requireAuth, allowFundsRelease);\n\nrouter.post(\"/:id/release\", requireAuth, releaseEscrowFunds);\n\nrouter.get(\"/unacked\", requireAuth, getUnackedEscrows);\nrouter.get(\"/:escrowId\", requireAuth, getSingleEscrow);\n\nrouter.get(\"/\", requireAuth, getUserEscrows);\n\n// router.post(\"/escrow/:id/check\", async (req: Request, res: Response) => {\n//   const escrow = escrows.get(req.params.id);\n//   if (!escrow) return res.status(404).json({ error: \"Not found\" });\n\n//   const utxos = await kaspaRpcService\n//     .getRpcClient()\n//     .getUtxosByAddresses([escrow.address]);\n//   const balance = utxos.reduce((a, u) => a + BigInt(u.amount), 0n);\n\n//   if (balance >= BigInt(escrow.amount)) {\n//     escrow.status = \"FUNDED\";\n//   }\n\n//   res.json({ balance: balance.toString(), status: escrow.status });\n// });\n\nexport default router;\n","import { hashToken } from \"../utils/hash.js\";\nimport { signSessionToken } from \"../utils/jwt.js\";\nimport { UserStore } from \"./auth.store.js\";\nimport type { IUser } from \"./User.model.js\";\n\nexport class UserService {\n  constructor(private readonly userStore: UserStore) {}\n\n  async findOrCreateUser(walletAddress: string): Promise<IUser> {\n    if (!walletAddress) {\n      throw new Error(\"Wallet address is required\");\n    }\n    const user = await this.userStore.findOrCreate(walletAddress);\n    if (user.isBanned) {\n      throw new Error(\"User is banned\");\n    }\n    return user;\n  }\n\n  issueJWT(user: IUser): string {\n    if (user.isBanned) {\n      throw new Error(\"User is banned\");\n    }\n\n    const tokenVersion = user.sessionToken.tokenVersion;\n\n    const sessionToken = signSessionToken({\n      sub: user._id.toString(),\n      wallet: user.walletAddress,\n      v: tokenVersion,\n      iat: Date.now(),\n    });\n\n    return sessionToken;\n  }\n\n  async getUserByWallet(walletAddress: string): Promise<IUser | null> {\n    if (!walletAddress) {\n      throw new Error(\"Wallet address is required\");\n    }\n    const user = await this.userStore.getByWallet(walletAddress);\n    if (!user) throw new Error(\"User not found\");\n    return user;\n  }\n\n  async getUserById(userId: string): Promise<IUser | null> {\n    if (!userId) {\n      throw new Error(\"user id is required\");\n    }\n    const user = await this.userStore.getById(userId);\n    if (!user) throw new Error(\"User not found\");\n    return user;\n  }\n\n  async banUser(walletAddress: string): Promise<IUser | null> {\n    return this.userStore.updateBanStatus(walletAddress, true);\n  }\n\n  async unbanUser(walletAddress: string): Promise<IUser | null> {\n    return this.userStore.updateBanStatus(walletAddress, false);\n  }\n\n  async invalidateUserSession(userId: string): Promise<IUser | null> {\n    if (!userId) {\n      throw new Error(\"User ID is required\");\n    }\n    return this.userStore.incrementTokenVersion(userId);\n  }\n}\n","import { User, type IUser } from \"./User.model.js\";\n\nexport class UserStore {\n  async createUser(walletAddress: string): Promise<IUser> {\n    const user = await User.create({ walletAddress });\n    return user;\n  }\n\n  async getByWallet(walletAddress: string): Promise<IUser | null> {\n    return await User.findOne({ walletAddress });\n  }\n\n  async getById(userId: string): Promise<IUser | null> {\n    return await User.findOne({ _id: userId });\n  }\n\n  async findOrCreate(walletAddress: string): Promise<IUser> {\n    const existingUser = await User.findOne({ walletAddress });\n\n    if (existingUser) return existingUser;\n\n    const user = await User.create({ walletAddress });\n    return user;\n  }\n\n  async updateSessionToken(\n    walletAddress: string,\n    tokenHash?: string,\n  ): Promise<IUser | null> {\n    if (!tokenHash) {\n      // Clear the token if no tokenHash is provided\n      return User.findOneAndUpdate(\n        { walletAddress },\n        { $set: { sessionToken: null } },\n        { new: true },\n      );\n    }\n\n    // Update or create the token object\n    const updatedUser = await User.findOneAndUpdate(\n      { walletAddress },\n      {\n        $set: {\n          sessionToken: {\n            tokenHash,\n            createdAt: new Date(),\n          },\n        },\n      },\n      { new: true, upsert: false }, // upsert false: don't create a new user if wallet doesn't exist\n    );\n\n    return updatedUser;\n  }\n\n  async updateBanStatus(\n    walletAddress: string,\n    isBanned: boolean,\n  ): Promise<IUser | null> {\n    return await User.findOneAndUpdate(\n      { walletAddress },\n      { isBanned },\n      { new: true },\n    );\n  }\n\n  async incrementTokenVersion(userId: string): Promise<IUser | null> {\n    return await User.findByIdAndUpdate(\n      userId,\n      { $inc: { \"sessionToken.tokenVersion\": 1 } },\n      { new: true },\n    );\n  }\n}\n","import { UserService } from \"../../auth/auth.service.js\";\nimport { UserStore } from \"../../auth/auth.store.js\";\nimport type { Request, Response } from \"express\";\nimport { catchError } from \"../../utils/catchError.js\";\n\nconst User = new UserService(new UserStore());\nconst cookieName = process.env.COOKIE_NAME!;\nexport const loginUser = async (req: Request, res: Response) => {\n  try {\n    const { walletAddress } = req.body;\n\n    if (!walletAddress || typeof walletAddress !== \"string\") {\n      return res.status(400).json({\n        success: false,\n        message: \"Wallet address must be provided as a string\",\n      });\n    }\n    const user = await User.findOrCreateUser(walletAddress);\n\n    if (!user) {\n      return res\n        .status(400)\n        .json({ success: false, message: \"User registration failed\" });\n    }\n\n    const sessionToken = User.issueJWT(user);\n\n    if (!sessionToken) {\n      return res\n        .status(400)\n        .json({ success: false, message: \"Error authorizing user\" });\n    }\n\n    // set cookie\n    res.cookie(cookieName, sessionToken, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === \"production\",\n      sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n      maxAge: 3 * 24 * 60 * 60 * 1000, // 3 days\n    });\n\n    return res.status(200).json({\n      success: true,\n      message: \"User logged in successfully\",\n      data: { id: user._id, wallet: user.walletAddress },\n    });\n  } catch (error) {\n    console.log(\"Error logging in user:\", error);\n    return catchError(res, error);\n  }\n};\n","import { UserService } from \"../../auth/auth.service.js\";\nimport { UserStore } from \"../../auth/auth.store.js\";\nimport type { Response, Request } from \"express\";\nimport { catchError } from \"../../utils/catchError.js\";\nimport { verifySessionToken } from \"../../utils/jwt.js\";\n\nconst User = new UserService(new UserStore());\nconst cookieName = process.env.COOKIE_NAME!;\n\nexport const logoutUser = async (req: Request, res: Response) => {\n  try {\n    const token = req.cookies[cookieName];\n\n    if (token) {\n      const payload = verifySessionToken(token);\n      const user = await User.getUserById(payload.sub);\n      if (user) {\n        // Increment token version to invalidate all existing JWTs\n        await User.invalidateUserSession(user?._id.toString());\n      }\n    }\n\n    // Clear the session cookie\n    res.clearCookie(cookieName, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === \"production\",\n      sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n    });\n\n    return res.status(200).json({\n      success: true,\n      message: \"User logged out successfully\",\n    });\n  } catch (error) {\n    console.log(\"Error logging out user:\", error);\n    return catchError(res, error);\n  }\n};\n","import { UserService } from \"../../auth/auth.service.js\";\nimport { UserStore } from \"../../auth/auth.store.js\";\nimport type { Request, Response } from \"express\";\nimport { catchError } from \"../../utils/catchError.js\";\nimport type { AuthRequest } from \"../../middleware/requireAuth.js\";\n\nconst User = new UserService(new UserStore());\nconst cookieName = process.env.COOKIE_NAME!;\nexport const getProfile = async (req: AuthRequest, res: Response) => {\n  try {\n    const user = req.user;\n    if (!user)\n      return res.status(401).json({\n        success: false,\n        message: \"Unauthorized to perfom this action\",\n      });\n\n    const id = req.user?.id;\n    const walletAddress = req.user?.wallet;\n\n    return res.status(200).json({\n      success: true,\n      message: \"User logged in successfully\",\n      data: { id, wallet: walletAddress },\n    });\n  } catch (error) {\n    console.log(\"Error logging in user:\", error);\n    return catchError(res, error);\n  }\n};\n","import { loginUser } from \"../auth/controllers/login.controller.js\";\nimport { logoutUser } from \"../auth/controllers/logout.controller.js\";\nimport { Router } from \"express\";\nimport { requireAuth } from \"../middleware/requireAuth.js\";\nimport { getProfile } from \"../auth/controllers/profile.controller.js\";\n\nconst authRoute: Router = Router();\n\nauthRoute.post(\"/wallet\", loginUser);\nauthRoute.post(\"/logout\", logoutUser);\nauthRoute.get(\"/profile\", requireAuth, getProfile);\n\nexport default authRoute;\n","import express, { Express } from \"express\";\nimport * as http from \"http\";\nimport * as WebSocket from \"ws\";\nimport swaggerJsdoc from \"swagger-jsdoc\";\nimport swaggerUi from \"swagger-ui-express\";\nimport kaspaRoutes from \"./routes/kaspaRoutes.js\";\nimport escrowRoutes from \"./routes/escrow.routes.js\";\nimport { kaspaRpcService } from \"./services/kaspaRpcService.js\";\nimport cookieParser from \"cookie-parser\";\nimport cors from \"cors\";\nimport authRoutes from \"./routes/auth.routes.js\";\nimport { RpcEventMap, sompiToKaspaString } from \"@kluster/kaspa-wasm-node\";\n\nconst app: Express = express();\napp.set(\"json replacer\", (_key: string, value: any) => {\n  // a replacer function to convert bigint to string\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return value;\n});\n\nconst allowedOrigins = [\"https://kascrow.vercel.app\", \"http://localhost:5173\"];\n\napp.use(\n  cors({\n    origin: (origin, callback) => {\n      if (!origin || allowedOrigins.includes(origin)) {\n        callback(null, true);\n      } else {\n        callback(new Error(\"Not allowed by CORS\"));\n      }\n    },\n    credentials: true,\n  }),\n);\n\napp.use(express.urlencoded({ extended: false }));\napp.use(cookieParser());\napp.use(express.json());\n\nconst swaggerOptions = {\n  swaggerDefinition: {\n    openapi: \"3.0.0\",\n    info: {\n      title: \"Kaspa Node.js Starter Kit API\",\n      version: \"1.0.0\",\n      description: \"API documentation for the Kaspa Node.js Starter Kit\",\n    },\n    servers: [\n      {\n        url: \"http://localhost:3000\",\n        description: \"Development server\",\n      },\n    ],\n  },\n  apis: [\"./src/routes/*.ts\"], // Path to the API docs\n};\n\nconst swaggerDocs = swaggerJsdoc(swaggerOptions);\napp.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(swaggerDocs));\n\napp.get(\"/\", (req, res) => {\n  res.send(\"Kaspa Node.js Starter Kit API\");\n});\n\n// Kaspa RPC routes\napp.use(\"/kaspa\", kaspaRoutes);\napp.use(\"/api/v1/escrow\", escrowRoutes);\napp.use(\"/api/v1/auth\", authRoutes);\n\n// Initialize WebSocket Server\nconst server = http.createServer(app);\nconst wss = new WebSocket.WebSocketServer({ server });\n\nconst stringify = (obj: any) =>\n  JSON.stringify(obj, (key, value) =>\n    typeof value === \"bigint\" ? value.toString() : value,\n  );\n\n// ... existing imports\n\nwss.on(\"connection\", (ws: WebSocket.WebSocket) => {\n  console.log(\"WebSocket client connected\");\n\n  ws.on(\"message\", async (message: string) => {\n    try {\n      const parsedMessage = JSON.parse(message.toString());\n      console.log(\"parsed message\", parsedMessage);\n      const { type, event, payload, requestId } = parsedMessage;\n\n      switch (type) {\n        // --- NEW: One-time balance request ---\n        case \"get-balance\":\n          if (!payload?.address)\n            return sendError(ws, \"Address required\", requestId);\n          try {\n            const res = await kaspaRpcService.getBalancesByAddresses([\n              payload.address,\n            ]);\n\n            const final = [\n              {\n                address: res.entries[0]?.address,\n                balance: sompiToKaspaString(res.entries[0]?.balance ?? 0n),\n              },\n            ];\n\n            console.log(final);\n            // FIX: Use the stringify helper here!\n            ws.send(\n              stringify({\n                type: \"balance-response\",\n                requestId,\n                data: final,\n              }),\n            );\n          } catch (err: any) {\n            sendError(ws, err.message, requestId);\n          }\n          break;\n\n        // --- NEW: Subscribe to real-time balance updates ---\n        case \"watch-address\":\n          if (!payload?.address)\n            return sendError(ws, \"Address required\", requestId);\n          try {\n            await kaspaRpcService.watchAddress(payload.address, ws);\n\n            // Optional: Send initial balance immediately so they don't wait for a change\n            const initialBalance = await kaspaRpcService.getBalancesByAddresses(\n              [payload.address],\n            );\n            ws.send(\n              JSON.stringify({\n                type: \"balance-update\",\n                address: payload.address,\n                data: initialBalance,\n              }),\n            );\n          } catch (err: any) {\n            sendError(ws, err.message, requestId);\n          }\n          break;\n\n        // --- EXISTING: Standard Events ---\n        case \"subscribe\":\n          if (event) kaspaRpcService.subscribe(event, ws);\n          break;\n\n        case \"unsubscribe\":\n          if (event) kaspaRpcService.unsubscribe(event, ws);\n          break;\n\n        default:\n          ws.send(JSON.stringify({ error: \"Unknown message type\" }));\n      }\n    } catch (error) {\n      console.error(\"Failed to parse WebSocket message:\", error);\n    }\n  });\n\n  ws.on(\"close\", () => {\n    console.log(\"WebSocket client disconnected\");\n    // CRITICAL: Clean up address listeners to prevent memory leaks\n    kaspaRpcService.unwatchAll(ws);\n\n    const allKnownEvents: (keyof RpcEventMap)[] = [\n      \"block-added\",\n      \"virtual-daa-score-changed\",\n      \"virtual-chain-changed\",\n    ];\n    allKnownEvents.forEach((event) => {\n      kaspaRpcService.unsubscribe(event, ws);\n    });\n  });\n});\n\n// Helper for cleaner errors\nfunction sendError(\n  ws: WebSocket.WebSocket,\n  message: string,\n  requestId?: string,\n) {\n  if (ws.readyState === WebSocket.WebSocket.OPEN) {\n    ws.send(JSON.stringify({ type: \"error\", message, requestId }));\n  }\n}\n\nexport { app, server, wss };\n","import { kaspaRpcService } from \"../services/kaspaRpcService.js\";\nimport { kaspaAddressListener } from \"./services/kaspaAddressListener.js\";\nimport EscrowService from \"./services/escrow.service.js\";\nimport EscrowStore from \"./escrow.store.js\";\nimport { Subscription } from \"./model/Subscription.js\";\nimport type { IEscrowUTXO } from \"./model/Escrow.js\";\nimport { SettlementService } from \"../settlement/settlement.service.js\";\nimport { SettlementStore } from \"../settlement/settlement.store.js\";\nimport { FileStorageService } from \"../settlement/files/fileStore.service.js\";\n\nconst Settlement = new SettlementService(\n  new SettlementStore(),\n  new FileStorageService(),\n);\nconst Escrow = new EscrowService(new EscrowStore(), Settlement);\n\nlet listenersAttached = false;\n\nexport async function startEscrowListener() {\n  console.log(\"üü¢ Escrow listener starting...\");\n\n  // 1Ô∏è‚É£ Ensure RPC is connected\n  try {\n    await kaspaRpcService.connect();\n  } catch (err) {\n    console.error(\"‚ùå Failed to connect Kaspa RPC:\", err);\n    return;\n  }\n\n  const rpc = kaspaRpcService.getRpcClient();\n\n  // 2Ô∏è‚É£ Load persisted addresses\n  const subscription = await Subscription.findOne({});\n  const addresses = (subscription?.addresses ?? [])\n    .map((a) => String(a).trim())\n    .filter((a) => a.length > 0);\n\n  console.log(\"üì° Initial sanitized addresses:\", addresses);\n\n  if (addresses.length > 0) {\n    try {\n      await kaspaAddressListener.init(addresses);\n    } catch (err) {\n      console.error(\"‚ùå Failed to subscribe to initial addresses:\", err);\n    }\n  } else {\n    console.warn(\"‚ö†Ô∏è No escrow addresses to subscribe yet\");\n  }\n\n  // 3Ô∏è‚É£ Attach listeners ONCE\n  if (!listenersAttached) {\n    listenersAttached = true;\n\n    // üîî UTXO listener\n    rpc.addEventListener(\"utxos-changed\", async (event: any) => {\n      try {\n        const added = event?.data?.added ?? [];\n        if (!added.length) return;\n\n        const utxosByAddress = new Map<string, IEscrowUTXO[]>();\n\n        for (const u of added) {\n          const address = u.address?.toString();\n          if (!address) continue;\n\n          const utxo: IEscrowUTXO = {\n            txId: u.outpoint.transactionId,\n            index: u.outpoint.index,\n            amount: Number(u.amount),\n            address,\n            confirmations: 0,\n            refunded: false,\n          };\n\n          if (!utxosByAddress.has(address)) utxosByAddress.set(address, []);\n          utxosByAddress.get(address)!.push(utxo);\n        }\n\n        for (const [address, utxos] of utxosByAddress.entries()) {\n          const escrow = await Escrow.getEscrowByAddress(address);\n          if (!escrow) continue;\n\n          await Escrow.applyFundingUpdate(escrow, utxos);\n        }\n      } catch (err) {\n        console.error(\"‚ùå utxos-changed handling failed:\", err);\n      }\n    });\n\n    // üîó Virtual chain listener\n    try {\n      await rpc.subscribeVirtualChainChanged(true);\n\n      rpc.addEventListener(\"virtual-chain-changed\", async () => {\n        try {\n          // Optional: confirmations / reorg safety\n        } catch (err) {\n          console.error(\"‚ùå virtual-chain handler failed:\", err);\n        }\n      });\n    } catch (err) {\n      console.error(\"‚ùå Failed to subscribe virtual chain:\", err);\n    }\n  }\n\n  console.log(\"üü¢ Escrow listener fully active\");\n}\n","import mongoose from \"mongoose\";\n\nconst mongoConnectionString = process.env.MONGO_CONNECTION_STRING || \"\";\n\nexport const connectDB = async () => {\n  try {\n    await mongoose.connect(mongoConnectionString);\n    console.log(\"üü¢ Connected to MongoDB\");\n  } catch (error) {\n    console.error(\"MongoDB connection error:\", error);\n    process.exit(1);\n  }\n};\n","// workers/escrowExpiry.worker.ts\nimport cron from \"node-cron\";\nimport EscrowStore from \"../escrow.store.js\";\nimport EscrowService from \"../services/escrow.service.js\";\n\n// Initialize store & service\nconst escrowStore = new EscrowStore();\nconst escrowService = new EscrowService(escrowStore);\n\n/**\n * Escrow Expiry Worker\n * - Runs every minute (configurable)\n * - Fetches all pending escrows\n * - Handles expiry and partial refunds\n * - Logs all operations\n */\ncron.schedule(\"*/2 * * * *\", async () => {\n  console.log(`[EscrowExpiryWorker] Running at ${new Date().toISOString()}`);\n\n  try {\n    const escrows = await escrowStore.getPendingEscrows();\n\n    if (escrows.length === 0) {\n      console.log(\"[EscrowExpiryWorker] No pending escrows found\");\n      return;\n    }\n\n    for (const escrow of escrows) {\n      try {\n        await escrowService.handlePossibleExpiry(escrow);\n\n        // Log status after processing\n        console.log(\n          `[EscrowExpiryWorker] Escrow ${escrow.escrowId} processed: ${escrow.status}`,\n        );\n      } catch (escrowErr) {\n        console.error(\n          `[EscrowExpiryWorker] Failed to process escrow ${escrow.escrowId}:`,\n          escrowErr,\n        );\n      }\n    }\n  } catch (err) {\n    console.error(\"[EscrowExpiryWorker] Worker failed:\", err);\n  }\n});\n\nconsole.log(\"[EscrowExpiryWorker] Cron worker scheduled (every 2 minutes)\");\n","import { server } from \"./app.js\";\nimport { kaspaRpcService } from \"./services/kaspaRpcService.js\";\nimport { startEscrowListener } from \"./escrow/escrow.listener.js\";\nimport { connectDB } from \"./config/mongo.js\";\nconst PORT = process.env.PORT ? parseInt(process.env.PORT, 10) : 3000;\nimport \"dotenv/config\";\nimport \"./escrow/workers/escrowExpiry.worker.js\";\n\nconst boot = async () => {\n  try {\n    console.log(\"Connecting to Kaspa RPC...\");\n    await kaspaRpcService.connect();\n    console.log(`Kaspa RPC connected to ${kaspaRpcService.getCurrentURL()}`);\n\n    await connectDB();\n    await startEscrowListener();\n    // console.log(await kaspaRpcService.getBlockDagInfo()); // Temporarily comment out for server startup\n  } catch (error) {\n    console.error(\"Failed to connect Kaspa RPC on boot:\", error);\n    // Depending on criticality, you might want to exit the process or try reconnecting\n  }\n\n  server.listen(PORT, \"0.0.0.0\", () => {\n    console.log(`Server is running on port ${PORT}`);\n    console.log(\"API documentation available at /api-docs\");\n  });\n};\n\nboot().catch(console.error);\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA,IAAM,kBAAN,MAAsB;CACpB,AAAQ,MAAwB;CAChC,AAAQ,cAAuB;CAC/B,AAAQ,8BAAqD,IAAI,KAAK;CACtE,AAAQ,oCAAwD,IAAI,KAAK;CACzE,AAAQ,qCAA4D,IAAI,KAAK;CAE7E,cAAc;AACZ,oCAAM,sBAAsB;;CAG9B,AAAO,gBAAgB;AACrB,SAAO,KAAK,KAAK;;CAGnB,MAAa,UAAU;AACrB,MAAI,KAAK,aAAa;AACpB,WAAQ,IAAI,sCAAsC;AAClD;;AAGF,OAAK,MAAM,IAAIA,oCAAU;GAGvB,UAAU,IAAIC,oCAAU;GACxB,WAAW;GACZ,CAAC;AAEF,MAAI;AACF,SAAM,KAAK,IAAI,QAAQ;IACrB,iBAAiB;IACjB,mBAAmB;IACpB,CAAC;AACF,QAAK,cAAc;AACnB,WAAQ,IAAI,8BAA8B;WACnC,OAAO;AACd,WAAQ,MAAM,0CAA0C,MAAM;AAC9D,QAAK,cAAc;AACnB,SAAM;;;CAIV,AAAO,eAA0B;AAC/B,MAAI,CAAC,KAAK,OAAO,CAAC,KAAK,YACrB,OAAM,IAAI,MAAM,qCAAqC;AAEvD,SAAO,KAAK;;CAGd,AAAO,iBAA0B;AAC/B,SAAO,KAAK;;CAGd,MAAa,kBAAkB;AAE7B,SADY,KAAK,cAAc,CACpB,iBAAiB;;CAG9B,MAAa,uBAAuB,WAAqB;AAEvD,SADY,KAAK,cAAc,CACpB,uBAAuB,EAAE,WAAW,CAAC;;CAGlD,AAAQ,UAAU,WAAmB,MAAW;EAC9C,MAAM,UAAU,KAAK,YAAY,IAAI,UAAU;AAC/C,MAAI,QACF,SAAQ,SAAS,SAAO;AACtB,OAAIC,KAAG,eAAeC,GAAU,UAAU,KACxC,MAAG,KAAK,KAAK,UAAU;IAAE,OAAO;IAAW;IAAM,CAAC,CAAC;IAErD;;CAIN,MAAa,yBAAyB;AAGpC,EAFY,KAAK,cAAc,CAE3B,iBAAiB,iBAAiB,OAAO,UAAe;GAC1D,MAAM,oCAAoB,IAAI,KAAa;AAG3C,SAAM,KAAK,OAAO,SAAS,MAAW;IACpC,MAAM,OACJ,OAAO,EAAE,YAAY,WAAW,EAAE,UAAU,EAAE,QAAQ,UAAU;AAClE,sBAAkB,IAAI,KAAK;KAC3B;AAEF,SAAM,KAAK,SAAS,SAAS,MAAW;IACtC,MAAM,OACJ,OAAO,EAAE,YAAY,WAAW,EAAE,UAAU,EAAE,QAAQ,UAAU;AAClE,sBAAkB,IAAI,KAAK;KAC3B;AAEF,QAAK,MAAM,WAAW,mBAAmB;IACvC,MAAM,UAAU,KAAK,mBAAmB,IAAI,QAAQ;AACpD,QAAI,WAAW,QAAQ,OAAO,EAC5B,KAAI;KACF,MAAM,cAAc,MAAM,KAAK,uBAAuB,CAAC,QAAQ,CAAC;KAEhE,MAAM,UAAU,KAAK,UAAU;MAC7B,MAAM;MACG;MACT,MAAM;MACP,CAAC;AAEF,aAAQ,SAAS,SAAO;AAEtB,UAAID,KAAG,eAAeC,GAAU,UAAU,KACxC,MAAG,KAAK,QAAQ;OAElB;aACK,KAAK;AACZ,aAAQ,MACN,uCAAuC,QAAQ,IAC/C,IACD;;;IAIP;;;;;CAKJ,MAAa,aAAa,SAAiB,MAAyB;AAClE,MAAI,CAAC,KAAK,mBAAmB,IAAI,QAAQ,EAAE;AACzC,QAAK,mBAAmB,IAAI,yBAAS,IAAI,KAAK,CAAC;AAI/C,SAAM,KAAK,cAAc,CAAC,sBAAsB,CAAC,QAAQ,CAAC;;AAG5D,OAAK,mBAAmB,IAAI,QAAQ,EAAE,IAAID,KAAG;;CAG/C,AAAO,eAAe,SAAiB,MAAyB;EAC9D,MAAM,UAAU,KAAK,mBAAmB,IAAI,QAAQ;AACpD,MAAI,QACF,SAAQ,OAAOA,KAAG;;;;;;CAStB,AAAO,WAAW,MAAyB;EACzC,IAAI,QAAQ;AAEZ,OAAK,mBAAmB,SAAS,SAAS,YAAY;AACpD,OAAI,QAAQ,IAAIA,KAAG,EAAE;AACnB,YAAQ,OAAOA,KAAG;AAClB;AAIA,QAAI,QAAQ,SAAS,EACnB,MAAK,mBAAmB,OAAO,QAAQ;;IAK3C;AAEF,MAAI,QAAQ,EACV,SAAQ,IACN,iBAAiB,MAAM,iDACxB;;CAIL,AAAO,UAAU,WAA8B,MAAyB;AACtE,MAAI,CAAC,KAAK,YAAY,IAAI,UAAU,EAAE;AACpC,QAAK,YAAY,IAAI,2BAAW,IAAI,KAAK,CAAC;AAC1C,QAAK,sBAAsB,UAAU;;AAEvC,OAAK,YAAY,IAAI,UAAU,EAAE,IAAIA,KAAG;AACxC,UAAQ,IACN,2BAA2B,UAAU,uBAAuB,KAAK,YAAY,IAAI,UAAU,EAAE,OAC9F;;CAGH,AAAO,YAAY,WAAmB,MAAyB;EAC7D,MAAM,UAAU,KAAK,YAAY,IAAI,UAAU;AAC/C,MAAI,SAAS;AACX,WAAQ,OAAOA,KAAG;AAClB,OAAI,QAAQ,SAAS,GAAG;AACtB,SAAK,YAAY,OAAO,UAAU;AAClC,SAAK,uBAAuB,UAAU;;;AAG1C,UAAQ,IACN,+BAA+B,UAAU,2BAA2B,KAAK,YAAY,IAAI,UAAU,EAAE,QAAQ,IAC9G;;CAGH,AAAQ,sBAAsB,WAA8B;AAC1D,MAAI,CAAC,KAAK,kBAAkB,IAAI,UAAU,EAAE;GAC1C,MAAME,YAAmC,UAAe;AACtD,SAAK,UAAU,WAAW,MAAM,KAAK;;AAEvC,QAAK,kBAAkB,IAAI,WAAW,SAAS;AAC/C,QAAK,cAAc,CAAC,iBAAiB,WAAW,SAAS;AACzD,WAAQ,IAAI,6CAA6C,YAAY;AAGrE,QAAK,wBAAwB,UAAU;;;CAI3C,AAAQ,uBAAuB,WAAmB;EAChD,MAAM,WAAW,KAAK,kBAAkB,IAAI,UAAU;AACtD,MAAI,UAAU;AACZ,QAAK,cAAc,CAAC,oBAAoB,WAAW,SAAS;AAC5D,QAAK,kBAAkB,OAAO,UAAU;AACxC,WAAQ,IAAI,+CAA+C,YAAY;;;CAI3E,MAAc,wBAAwB,WAAmB;AACvD,MAAI;AACF,WAAQ,WAAR;IACE,KAAK;AACH,WAAM,KAAK,cAAc,CAAC,qBAAqB;AAC/C;IACF,KAAK;AACH,WAAM,KAAK,cAAc,CAAC,iCAAiC;AAC3D;IACF,KAAK;AACH,WAAM,KAAK,cAAc,CAAC,6BAA6B,KAAK;AAC5D;IAEF,QACE,SAAQ,KACN,mDAAmD,YACpD;;AAEL,WAAQ,IAAI,kCAAkC,YAAY;WACnD,OAAO;AACd,WAAQ,MACN,yCAAyC,UAAU,IACnD,MACD;;;;AAKP,MAAa,kBAAkB,IAAI,iBAAiB;;;;AC/PpD,MAAMC,gCAAyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqC/BC,SAAO,IAAI,YAAY,OAAO,KAAc,QAAkB;AAC5D,KAAI;AACF,MAAI,CAAC,gBAAgB,gBAAgB,CACnC,QAAO,IACJ,OAAO,IAAI,CACX,KAAK,EAAE,OAAO,sCAAsC,CAAC;EAE1D,MAAM,UAAU,MAAM,gBAAgB,iBAAiB;AACvD,MAAI,KAAK,QAAQ;UACVC,OAAY;AACnB,MAAI,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,MAAM,SAAS,CAAC;;EAEhD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEFD,SAAO,KAAK,aAAa,OAAO,KAAc,QAAkB;AAC9D,KAAI;AACF,MAAI,CAAC,gBAAgB,gBAAgB,CACnC,QAAO,IACJ,OAAO,IAAI,CACX,KAAK,EAAE,OAAO,sCAAsC,CAAC;EAE1D,MAAM,EAAE,cAAc,IAAI;AAC1B,MAAI,CAAC,aAAa,CAAC,MAAM,QAAQ,UAAU,IAAI,UAAU,WAAW,EAClE,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,gCAAgC,CAAC;EAExE,MAAM,WAAW,MAAM,gBAAgB,uBAAuB,UAAU;AACxE,MAAI,KAAK,SAAS;UACXC,OAAY;AACnB,MAAI,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,MAAM,SAAS,CAAC;;EAEhD;AAEF,0BAAeD;;;;ACtIf,MAAM,YAAY;CAChB,SAAS;CACT,kBAAkB;CAClB,kBAAkB;CAClB,QAAQ;CAER,kBAAkB;CAClB,UAAU;CACV,UAAU;CACV,UAAU;CACV,SAAS;CACV;AAID,0BAAe;;;;ACZf,MAAM,aAAa;AACnB,MAAM,YAAY;AAElB,MAAM,OAAO,OAAO,KAClB,QAAQ,IAAI,mBAAmB,yBAChC;AAED,MAAa,YAAY,YAA6B;CACpD,MAAM,eAAe,QAAQ,IAAI;AACjC,KAAI,CAAC,aACH,OAAM,IAAI,MAAM,+BAA+B;AAGjD,QAAO,eAAO,KAAK,cAAc;EAC/B,MAAM,eAAO;EACb,MAAM;EACN,YAAY,KAAK;EACjB,UAAU;EACV,aAAa;EACb,YAAY;EACZ,KAAK;EACN,CAAC;;AAGJ,MAAa,UAAU,OAAO,SAAkC;CAC9D,MAAM,MAAM,MAAM,WAAW;CAC7B,MAAM,KAAK,eAAO,YAAY,GAAG;CAEjC,MAAM,SAAS,eAAO,eAAe,WAAW,KAAK,GAAG;CACxD,MAAM,YAAY,OAAO,OAAO,CAC9B,OAAO,OAAO,MAAM,OAAO,EAC3B,OAAO,OAAO,CACf,CAAC;CACF,MAAM,MAAM,OAAO,YAAY;AAE/B,QAAO,OAAO,OAAO;EAAC;EAAI;EAAK;EAAU,CAAC,CAAC,SAAS,SAAS;;AAG/D,MAAa,UAAU,OAAO,YAAqC;CACjE,MAAM,MAAM,MAAM,WAAW;CAC7B,MAAM,OAAO,OAAO,KAAK,SAAS,SAAS;CAE3C,MAAM,KAAK,KAAK,SAAS,GAAG,GAAG;CAC/B,MAAM,MAAM,KAAK,SAAS,IAAI,GAAG;CACjC,MAAM,YAAY,KAAK,SAAS,GAAG;CAEnC,MAAM,WAAW,eAAO,iBAAiB,WAAW,KAAK,GAAG;AAC5D,UAAS,WAAW,IAAI;AAOxB,QALkB,OAAO,OAAO,CAC9B,SAAS,OAAO,UAAU,EAC1B,SAAS,OAAO,CACjB,CAAC,CAEe,SAAS,OAAO;;;;;ACzDnC,MAAM,oBAAoB;AAC1B,MAAM,uBAAuB;AAC7B,MAAM,oBAAoB;AAE1B,MAAa,kBACX,oBAAoB,uBAAuB;;;;ACL7C,IAAqB,WAArB,cAAsC,MAAM;CAC1C,AAAgB;CAChB,AAAgB;CAEhB,YAAY,SAAiB,YAAoB;AAC/C,QAAM,QAAQ;AACd,OAAK,aAAa;AAClB,OAAK,gBAAgB;AAErB,QAAM,kBAAkB,MAAM,KAAK,YAAY;;;;;;ACNnD,IAAa,oBAAb,cAAuC,SAAS;CAC9C,YAAY,UAAU,gBAAgB;AACpC,QAAM,SAAS,IAAI;;;AAUvB,IAAa,gBAAb,cAAmC,SAAS;CAC1C,YAAY,UAAU,sBAAsB;AAC1C,QAAM,SAAS,IAAI;;;AAIvB,IAAa,kBAAb,cAAqC,SAAS;CAC5C,YAAY,UAAU,eAAe;AACnC,QAAM,SAAS,IAAI;;;AAIvB,IAAa,sBAAb,cAAyC,SAAS;CAChD,YAAY,UAAU,yBAAyB;AAC7C,QAAM,SAAS,IAAI;;;;;;ACxBvB,MAAME,qBAA8D;CAClE,SAAS;EACP,kBAAkB,CAAC,SAAS;EAC5B,SAAS,CAAC,SAAS;EACpB;CAED,kBAAkB;EAChB,kBAAkB,CAAC,SAAS;EAC5B,QAAQ,CAAC,SAAS;EAClB,SAAS,CAAC,SAAS;EACpB;CAED,kBAAkB;EAChB,QAAQ,CAAC,SAAS;EAClB,SAAS,CAAC,SAAS;EACpB;CAED,QAAQ;EACN,kBAAkB,CAAC,QAAQ;EAC3B,UAAU,CAAC,SAAS,SAAS;EAC9B;CAED,kBAAkB;EAChB,UAAU,CAAC,QAAQ;EACnB,UAAU,CAAC,SAAS;EACrB;CAED,UAAU,EAAE;CAEZ,UAAU,EAAE;CAEZ,SAAS,EAAE;CACZ;AAED,SAAgB,oBACd,QACA,YACA,OACA;CACA,MAAM,cAAc,mBAAmB,OAAO;AAC9C,KAAI,CAAC,eAAe,CAAC,YAAY,YAC/B,OAAM,IAAI,MACR,8BAA8B,OAAO,OAAO,KAAK,aAClD;AAIH,KAAI,CADkB,YAAY,YACf,SAAS,MAAM,CAChC,OAAM,IAAI,MACR,SAAS,MAAM,kBAAkB,OAAO,OAAO,KAAK,aACrD;;;;;ACnCL,MAAM,qBAAqB,IAAIC,gBAC7B,EAEE,cAAc;CAAE,MAAM;CAAQ,SAAS;CAAG,EAC3C,EACD,EACE,YAAY,MACb,CACF;AAED,MAAM,aAAa,IAAIA,gBACrB;CACE,eAAe;EACb,MAAM;EACN,UAAU;EACV,QAAQ;EACR,OAAO;EACP,WAAW;EACX,MAAM;EACP;CACD,cAAc;EAAE,MAAM;EAAoB,gBAAgB,EAAE;EAAG;CAE/D,UAAU;EACR,MAAM;EACN,SAAS;EACV;CACF,EACD,EACE,YAAY,MACb,CACF;AAED,MAAaC,6BAAoB,QAAQ,WAAW;;;;ACpDpD,MAAa,6BAA6B,OAAU;AACpD,MAAa,6BAA6B,OAAU;AAEpD,MAAM,kBAAkB;CACtB,MAAM;CACN,UAAU;CACX;AAGD,sBAAe;;;;ACFf,SAAgB,oBAAoB,QAAyB;AAC3D,QAAO,OAAO,MACX,QAAQ,MAAM,CAAC,EAAE,SAAS,CAC1B,QAAQ,KAAK,MAAM,MAAM,OAAO,EAAE,OAAO,EAAE,GAAG;;AAGnD,eAAsB,kBAAkB,eAAuB;AAC7D,KAAI,CAAC,gBAAgB,gBAAgB,CAAE,OAAM,IAAI,qBAAqB;AACtE,KAAI,OAAO,kBAAkB,SAC3B,OAAM,IAAI,gBAAgB,2BAA2B;CAEvD,MAAM,UAAU,MAAM,gBAAgB,uBAAuB,CAAC,cAAc,CAAC;AAC7E,KAAI,CAAC,QAAS,OAAM,IAAI,gBAAgB,kBAAkB;AAC1D,QAAO;;;;;ACRT,eAAsB,cAAc,QAAiB;AACnD,qBAAoB,QAAQC,oBAAU,UAAU,SAAS;AAEzD,KAAI,OAAO,WAAY;CAEvB,MAAM,aAAa,oBAAoB,OAAO;AAC9C,KAAI,eAAe,GAAI;CAEvB,MAAM,MAAM,gBAAgB,cAAc;CAE1C,MAAM,sBAAsB,MAAM,QAAQ,OAAO,oBAAoB;CACrE,MAAM,UAAU,QAAQ,IAAI,iBAAiB;CAC7C,MAAM,aAAa,IAAIC,qCAAW,oBAAoB;CAEtD,MAAM,cAAc,WAAW,UAAU,QAAQ,CAAC,UAAU;CAE5D,MAAM,SADe,MAAM,IAAI,oBAAoB,CAAC,YAAY,CAAC,EACtC,WAAW,EAAE;AAExC,KAAI,MAAM,WAAW,EACnB,OAAM,IAAI,MAAM,6BAA6B;CAG/C,MAAM,cAAc;AAIpB,KAFmB,MAAM,QAAQ,KAAK,SAAS,MAAM,OAAO,KAAK,OAAO,EAAE,GAAG,GAE5D,WACf,OAAM,IAAI,MAAM,yCAAyC;CAG3D,MAAM,wBACJ,aAAa,cAAc,aAAa,cAAc;AAExD,KAAI,yBAAyB,GAC3B,OAAM,IAAI,MAAM,mCAAmC;CAGrD,MAAM,sDACJ,OACA,CACE;EACE,SAAS,OAAO;EAChB,QAAQ;EACT,CACF,EACD,YACD;AAED,gDAAgB,IAAI,CAAC,WAAW,EAAE,KAAK;AACvC,IAAG,UAAU;CAGb,MAAM,eAAe,MAAM,IAAI,kBAAkB,EAC/C,aAAa,IACd,CAAC;AAGF,MAAK,MAAM,QAAQ,OAAO,OAAO;AAC/B,MAAI,KAAK,SAAU;AACnB,OAAK,WAAW;AAChB,OAAK,aAAa,aAAa;AAC/B,OAAK,6BAAa,IAAI,MAAM;;AAE9B,QAAO,SAASD,oBAAU;AAC1B,QAAO,aAAa,aAAa;AACjC,QAAO,6BAAa,IAAI,MAAM;AAC9B,OAAM,OAAO,MAAM;;;;;ACzDrB,eAAsB,eAAe,QAAiB,UAAkB;CAEtE,MAAME,SADO,MAAMC,OAAK,SAAS,SAAS,GAElC,kBAAkB,OAAO,eAAe,UAAU;AAC1D,qBAAoB,QAAQC,oBAAU,UAAU,MAAM;AACtD,SAAQ,IAAI,eAAe,QAAQ,OAAO,oBAAoB;AAC9D,KAAI,OAAO,WAAWA,oBAAU,SAC9B,OAAM,IAAI,MAAM,0BAA0B;AAG5C,SAAQ,IAAI,yBAAyB;AACrC,KACE,OAAO,WAAWA,oBAAU,UAC5B,OAAO,WAAWA,oBAAU,iBAE5B,OAAM,IAAI,MAAM,wCAAwC;AAG1D,SAAQ,IAAI,yBAAyB;CAErC,MAAM,MAAM,gBAAgB,cAAc;AAE1C,SAAQ,IAAI,iBAAiB,IAAI;AAGjC,KAAI,CAAC,OAAO,oBACV,OAAM,IAAI,MAAM,gCAAgC;AAElD,SAAQ,IAAI,OAAO,oBAAoB;CACvC,MAAM,sBAAsB,MAAM,QAAQ,OAAO,oBAAoB;AACrE,SAAQ,IAAI,aAAa,oBAAoB;AAE7C,KAAI,CAAC,oBACH,OAAM,IAAI,MAAM,uCAAuC;AAEzD,SAAQ,IAAI,kBAAkB;CAC9B,MAAM,aAAa,IAAIC,qCAAW,oBAAoB;CACtD,MAAM,UAAU,QAAQ,IAAI,iBAAiB;CAE7C,MAAM,cAAc,WAAW,UAAU,QAAQ,CAAC,UAAU;CAI5D,MAAM,SADe,MAAM,IAAI,oBAAoB,CAAC,YAAY,CAAC,EACtC,WAAW,EAAE;AAExC,KAAI,MAAM,WAAW,EACnB,OAAM,IAAI,MAAM,8CAA8C;AAGhE,SAAQ,IAAI,oBAAoB;CAEhC,MAAM,aAAa,MAAM,QAAQ,KAAK,SAAS,MAAM,OAAO,KAAK,OAAO,EAAE,GAAG;AAC7E,KACE,aAAa,mDAAoB,OAAO,eAAe,UAAU,CAAC,IAAI,GAAG,CAEzE,OAAM,IAAI,MAAM,qBAAqB;CAGvC,MAAM,cAAc;CAEpB,MAAM,aAAa,OAAO;CAE1B,MAAM,8DAA+B,WAAW,UAAU,CAAC,IAAI;AAC/D,KAAI,aAAa,kBAAkB,YACjC,OAAM,IAAI,MAAM,uCAAuC;CAGzD,MAAM,sDACJ,OACA,CACE;EACE,SAAS,OAAO;EAChB,QAAQ;EACT,CACF,EACD,YACD;AAED,SAAQ,IAAI,sBAAsB;AAGlC,gDAAgB,IAAI,CAAC,WAAW,EAAE,KAAK;AAGvC,IAAG,UAAU;CAGb,MAAM,eAAe,MAAM,IAAI,kBAAkB,EAC/C,aAAa,IACd,CAAC;AAEF,QAAO,SAASD,oBAAU;AAC1B,QAAO,cAAc,aAAa;AAClC,OAAM,OAAO,MAAM;AAEnB,QAAO,aAAa;;AAGtB,eAAsBE,oBACpB,QACA,OACA,YACA,qBACA;CACA,MAAMC,kBAAoC,EAAE;AAC5C,KAAI,WAAW,SAAS,QAAQ;EAC9B,MAAM,EAAE,SAAS,MAAMC,oBAAkB,YAAY,YAAY,MAAM;AACvE,UAAQ,IAAI,kBAAkB,KAAK;AACnC,kBAAgB,UAAU;YACjB,WAAW,SAAS,YAAY;EACzC,MAAM,OAAO,MAAMA,oBAAkB,gBAAgB,YAAY,MAAM;AACvE,kBAAgB,OAAO;AACvB,UAAQ,IAAI,QAAQ,KAAK;OACpB,OAAM,IAAI,gBAAgB,0BAA0B;AAE3D,KAAI,OAAO,WAAWJ,oBAAU,OAC9B,OAAM,IAAI,gBAAgB,+BAA+B;AAG3D,QAAO,SAASA,oBAAU;AAC1B,OAAM,OAAO,MAAM;AACnB,QAAO;;;;;ACtET,MAAM,eAAe,IAAIK,gBACvB;CACE,UAAU;EAAE,MAAM;EAAQ,UAAU;EAAM,QAAQ;EAAM;CACxD,OAAO;EAAE,MAAM;EAAQ,UAAU;EAAM;CAEvC,cAAc;EAAE,MAAM;EAAQ,UAAU;EAAM,OAAO;EAAM;CAC3D,eAAe;EAAE,MAAM;EAAQ,UAAU;EAAM,OAAO;EAAM;CAE5D,eAAe;EAAE,MAAM;EAAQ,UAAU;EAAM,QAAQ;EAAM;CAC7D,qBAAqB;EAAE,MAAM;EAAQ,UAAU;EAAM;CAErD,QAAQ;EAAE,MAAM;EAAQ,UAAU;EAAM;CACxC,gBAAgB;EAAE,MAAM;EAAQ,UAAU;EAAM;CAChD,cAAc;EAAE,MAAM;EAAQ,SAAS;EAAG;CAE1C,QAAQ;EACN,MAAM;EACN,MAAM,OAAO,OAAOC,oBAAU;EAC9B,UAAU;EACV,OAAO;EACR;CAED,OAAO,CACL;EACE,MAAM;EACN,OAAO;EACP,QAAQ;EACR,eAAe;EAChB,CACF;CAED,cAAc,CAAC,EAAE,MAAM,QAAQ,CAAC;CAChC,aAAa,EAAE,MAAM,QAAQ;CAC7B,YAAY,EAAE,MAAM,QAAQ;CAC5B,YAAY,EAAE,MAAM,MAAM;CAE1B,mBAAmB,EAAE,MAAM,MAAM;CACjC,UAAU,EAAE,MAAM,MAAM;CACxB,iBAAiB,EAAE,MAAM,MAAM;CAC/B,sBAAsB,EAAE,MAAM,MAAM;CACpC,WAAW;EAAE,MAAM;EAAQ,UAAU;EAAM,OAAO;EAAM;CACxD,WAAW;EAAE,MAAM;EAAM,OAAO;EAAM;CACtC,YAAY,EAAE,MAAM,MAAM;CAC3B,EACD,EAAE,YAAY,MAAM,CACrB;AAGD,aAAa,MAAM;CAAE,cAAc;CAAG,QAAQ;CAAG,CAAC;AAClD,aAAa,MAAM;CAAE,eAAe;CAAG,QAAQ;CAAG,CAAC;AAEnD,MAAaC,WAAS,iBAAS,MAAe,UAAU,aAAa;;;;ACrHrE,eAAsB,qBACpB,QACA,OACA;CACA,MAAMC,eAAiC,EAAE;CAGzC,MAAM,UAAU,MAAM,QAAQ,GAAG,MAAM,IAAI,OAAO,EAAE,OAAO,EAAE,GAAG;CAChE,MAAM,4DAA6B,OAAO,eAAe,UAAU,CAAC,IAAI;AAExE,cAAa,eAAe,yDAA0B,QAAQ,CAAC;CAG/D,MAAM,mBAAmB,IAAI,IAC3B,OAAO,MAAM,KAAK,MAAM,GAAG,EAAE,KAAK,GAAG,EAAE,QAAQ,CAChD;CAED,MAAM,WAAW,MAAM,QACpB,MAAM,CAAC,iBAAiB,IAAI,GAAG,EAAE,KAAK,GAAG,EAAE,QAAQ,CACrD;AAED,KAAI,SAAS,SAAS,EACpB,cAAa,QAAQ,CAAC,GAAG,OAAO,OAAO,GAAG,SAAS;CAIrD,MAAM,gBAAgB,IAAI,IAAI,OAAO,gBAAgB,EAAE,CAAC;CACxD,MAAM,WAAW,SACd,KAAK,MAAM,EAAE,KAAK,CAClB,QAAQ,SAAS,CAAC,cAAc,IAAI,KAAK,CAAC;AAE7C,KAAI,SAAS,SAAS,EACpB,cAAa,eAAe,CAAC,GAAI,OAAO,gBAAgB,EAAE,EAAG,GAAG,SAAS;AAI3E,KAAI,UAAU,eAAe;AAC3B,sBAAoB,QAAQC,oBAAU,kBAAkB,SAAS;AAEjE,eAAa,SAASA,oBAAU;AAChC,eAAa,oCAAoB,IAAI,MAAM;QACtC;AACL,sBAAoB,QAAQA,oBAAU,QAAQ,SAAS;AAEvD,eAAa,SAASA,oBAAU;AAChC,eAAa,2BAAW,IAAI,MAAM;;AAIpC,OAAMC,SAAO,kBACX,OAAO,KACP,EAAE,MAAM,cAAc,EACtB,EAAE,KAAK,OAAO,CACf;;;;;AChDH,MAAM,qBAAqB,IAAIC,gBAAsB,EACnD,WAAW;CAAE,MAAM,CAAC,OAAO;CAAE,SAAS,EAAE;CAAE,EAC3C,CAAC;AAGF,mBAAmB,QAAQ,eAAe,eACxC,cACA;CACA,IAAI,MAAM,MAAM,KAAK,SAAS;AAC9B,KAAI,CAAC,IACH,OAAM,MAAM,KAAK,OAAO,EAAE,WAAW,EAAE,EAAE,CAAC;AAI5C,KAAI,YAAY,MAAM,KAAK,IAAI,IAAI,CAAC,GAAG,IAAI,WAAW,GAAG,aAAa,CAAC,CAAC;AACxE,OAAM,IAAI,MAAM;AAChB,QAAO;;AAIT,mBAAmB,QAAQ,eAAe,iBAAkB;AAE1D,SADY,MAAM,KAAK,SAAS,GACpB,aAAa,EAAE;;AAG7B,MAAa,eAAe,iBAAS,MACnC,gBACA,mBACD;;;;ACrCD,IAAM,uBAAN,MAA2B;CACzB,AAAQ,MAAkB;CAC1B,AAAQ,sCAAsB,IAAI,KAAa;CAC/C,AAAQ,eAAe;CAEvB,AAAQ,SAAS;AACf,MAAI,CAAC,KAAK,IACR,MAAK,MAAM,gBAAgB,cAAc;AAE3C,SAAO,KAAK;;CAGd,MAAM,KAAK,kBAA4B;AACrC,mBAAiB,SAAS,MAAM,KAAK,oBAAoB,IAAI,EAAE,CAAC;AAChE,QAAM,KAAK,aAAa;;CAG1B,MAAM,WAAW,SAAiB;AAChC,MAAI,CAAC,WAAW,KAAK,oBAAoB,IAAI,QAAQ,CAAE;AAEvD,OAAK,oBAAoB,IAAI,QAAQ;AACrC,QAAM,KAAK,aAAa;;CAG1B,MAAM,aAAa,WAAqB;EACtC,IAAI,UAAU;AACd,OAAK,MAAM,QAAQ,UACjB,KAAI,QAAQ,CAAC,KAAK,oBAAoB,IAAI,KAAK,EAAE;AAC/C,QAAK,oBAAoB,IAAI,KAAK;AAClC,aAAU;;AAId,MAAI,QAAS,OAAM,KAAK,aAAa;;CAGvC,MAAc,cAAc;EAE1B,MAAM,YAAY,MAAM,KAAK,KAAK,oBAAoB,CACnD,KAAK,MAAM,OAAO,EAAE,CAAC,MAAM,CAAC,CAC5B,QAAQ,MAAM,EAAE,SAAS,EAAE;AAE9B,MAAI,UAAU,WAAW,GAAG;AAC1B,WAAQ,KAAK,qCAAqC;AAClD;;AAGF,UAAQ,IAAI,gCAAgC,UAAU;EAEtD,MAAM,MAAM,KAAK,QAAQ;AAGzB,MAAI,KAAK,aACP,KAAI;AACF,SAAM,IAAI,yBAAyB;WAC5B,KAAK;AACZ,WAAQ,KAAK,gDAAgD,IAAI;;AAKrE,MAAI;AACF,SAAM,IAAI,sBAAsB,UAAU;AAC1C,QAAK,eAAe;AACpB,WAAQ,IAAI,8BAA8B,UAAU,OAAO;WACpD,KAAK;AACZ,WAAQ,MAAM,oCAAoC,KAAK,UAAU;;;;AAKvE,MAAa,uBAAuB,IAAI,sBAAsB;;;;ACxC9D,IAAqB,gBAArB,MAAmC;CACjC,YACE,AAAiBC,eACjB,AAAiBC,qBACjB;EAFiB;EACA;;CAGnB,MAAM,aACJ,OACA,QACA,cACA,eACkB;AAClB,MAAI,MAAM,SAAS,EACjB,OAAM,IAAI,gBAAgB,uCAAuC;EAEnE,MAAM,iBAAiB,SADO;EAG9B,MAAM,UAAU,QAAQ,IAAI,iBAAiB;EAE7C,MAAM,WAAW,eAAO,YAAY;EAGpC,MAAM,gBAAgB,eAAO,YAAY,GAAG,CAAC,SAAS,MAAM;EAM5D,MAAM,gBAHa,IAAIC,qCAAW,cAAc,CAGf,UAAU,QAAQ,CAAC,UAAU;EAE9D,MAAM,sBAAsB,MAAM,QAAQ,cAAc;EAExD,MAAM,YAAY,KAAK,KAAK,GAAG;EAE/B,MAAM,SAAS,MAAM,KAAK,YAAY,OAAO;GAC3C;GACA;GACA;GACA;GACA;GACA;GACA,gBAAgB;GAChB;GACA,QAAQC,oBAAU;GAClB;GACD,CAAC;AAEF,QAAM,aAAa,UACjB,EAAE,EACF,EAAE,WAAW,EAAE,WAAW,eAAe,EAAE,EAC3C,EAAE,QAAQ,MAAM,CACjB;AAED,QAAM,qBAAqB,WAAW,cAAc;AAEpD,UAAQ,IAAI,qCAAqC,OAAO,WAAW;AAEnE,SAAO;;CAKT,MAAM,iBACJ,UACA,UACA,gBACA;EACA,MAAM,EAAE,QAAQ,UAAU,MAAM,KAAK,kBAAkB,UAAU,SAAS;AAE1E,sBAAoB,QAAQA,oBAAU,kBAAkB,MAAM;EAC9D,MAAM,QAAQ;GACZ,QAAQ,OAAO,IAAI,UAAU;GAC7B,GAAG;GACJ;AACD,UAAQ,IAAI,mBAAmB;EAC/B,MAAM,aAAa,MAAM,KAAK,kBAAkB,OAAO,MAAM;AAC7D,UAAQ,IAAI,kCAAkC;AAC9C,SAAO,SAASA,oBAAU;AAC1B,SAAO,uCAAuB,IAAI,MAAM;AAExC,QAAM,OAAO,MAAM;AACnB,SAAO;;CAIT,MAAM,aACJ,UACA,UACmC;EACnC,MAAM,EAAE,QAAQ,UAAU,MAAM,KAAK,kBAAkB,UAAU,SAAS;AAC1E,UAAQ,IAAI,SAAS,OAAO,OAAO,OAAO;AAC1C,sBAAoB,QAAQA,oBAAU,kBAAkB,MAAM;AAC9D,UAAQ,IAAI,mBAAmB;EAC/B,MAAM,aAAa,MAAM,KAAK,kBAAkB,qBAC9C,OAAO,IAAI,UAAU,CACtB;AACD,UAAQ,IAAI,oBAAoB,WAAW;AAC3C,SAAOC,oBACL,QACA,OACA,YACA,KAAK,kBACN;;CAIH,MAAc,YAAY,QAAiB;AACzC,SAAOC,cAAqB,OAAO;;CAIrC,MAAc,kBAAkB,UAAkB,UAAkB;EAClE,MAAM,SAAS,MAAM,KAAK,cAAc,SAAS;AACjD,MAAI,CAAC,OAAQ,OAAM,IAAI,cAAc,mBAAmB;EAExD,MAAM,SAAS,MAAMC,OAAK,QAAQ,EAAE,KAAK,UAAU,CAAC;AACpD,MAAI,CAAC,OACH,OAAM,IAAI,cAAc,uCAAuC;AAGjE,SAAO;GAAE;GAAQ,OADf,OAAO,kBAAkB,OAAO,gBAAgB,WAAW;GACrC;;CAI1B,MAAM,mBAAmB,QAAiB,OAAsB;AAC9D,SAAOC,qBAA6B,QAAQ,MAAM;;CAIpD,MAAM,6BAA6B,QAAiB;AAClD,sBAAoB,QAAQJ,oBAAU,SAAS,SAAS;AAExD,QAAM,KAAK,YAAY,OAAO;AAC9B,SAAO,SAASA,oBAAU;AAC1B,SAAO,4BAAY,IAAI,MAAM;AAE7B,QAAM,OAAO,MAAM;;CAIrB,MAAM,qBAAqB,QAAiB;AAC1C,UAAQ,IAAI,QAAQ;EAEpB,MAAM,MAAM,KAAK,KAAK;EACtB,MAAM,YAAY,OAAO,OAAO;AAEhC,UAAQ,IAAI,SAAS,WAAW;GAC9B;GACA,WAAW,OAAO;GACnB,CAAC;AAEF,UAAQ,IAAI,SAAS,UAAU;AAC/B,MAAI,CAAC,UAAW;AAChB,UAAQ,OAAO,QAAf;GACE,KAAKA,oBAAU;GACf,KAAKA,oBAAU;AAEb,wBAAoB,QAAQA,oBAAU,SAAS,SAAS;AAExD,WAAO,SAASA,oBAAU;AAC1B,WAAO,YAAY,IAAI,KAAK,IAAI;AAChC;GAGF,KAAKA,oBAAU;AACb,UAAM,KAAK,6BAA6B,OAAO;AAC/C;;AAIJ,QAAM,OAAO,MAAM;;CAGrB,MAAM,mBAAmB,eAAgD;AACvE,SAAO,KAAK,YAAY,aAAa,cAAc;;CAGrD,MAAM,oBAAoB,aAAyC;AACjE,SAAO,KAAK,YAAY,oBAAoB,YAAY;;CAG1D,MAAM,iBAAiB,eAAuB;AAC5C,SAAO,kBAAkB,cAAc;;CAGzC,MAAM,cAAc,UAA2C;AAC7D,SAAO,KAAK,YAAY,QAAQ,SAAS;;CAG3C,MAAM,oBAAoB;AACxB,SAAO,KAAK,YAAY,mBAAmB;;CAG7C,MAAM,uBAAuB,SAAiB;AAC5C,SAAO,KAAK,YAAY,sBAAsB,QAAQ;;CAGxD,MAAM,kBAAkB,SAAiB;AACvC,SAAO,KAAK,YAAY,kBAAkB,QAAQ;;CAGpD,MAAM,kBAAkB,SAAiB;AASvC,SAAO;GACL,gBATqB,MAAM,KAAK,YAAY,mBAAmB,EAAE;GAUjE,mBARA,MAAM,KAAK,YAAY,wBAAwB,QAAQ,EACvD;GAQA,iBAPsB,MAAM,KAAK,kBAAkB,QAAQ,EAAE;GAQ7D,eAPoB,MAAM,KAAK,YAAY,qBAAqB,QAAQ;GAQxE,eAPoB,MAAM,KAAK,YAAY,qBAAqB,QAAQ;GAQzE;;CAGH,MAAM,mBAAmB,UAAkB,UAAkB;EAC3D,MAAM,SAAS,MAAM,KAAK,YAAY,QAAQ,SAAS;AACvD,MAAI,CAAC,OACH,OAAM,IAAI,MAAM,mBAAmB;AAErC,SAAOK,eAAuB,QAAQ,SAAS;;;;;;AC7PnD,IAAqB,cAArB,MAAiC;CAC/B,MAAM,OAAO,MAAyC;AAEpD,SADe,MAAMC,SAAO,OAAO,KAAK;;CAI1C,MAAM,QAAQ,UAA2C;AACvD,SAAOA,SAAO,QAAQ,EAAE,UAAU,CAAC;;CAGrC,MAAM,aAAa,eAAgD;AACjE,SAAOA,SAAO,QAAQ,EAAE,eAAe,CAAC;;CAG1C,MAAM,oBAAoB,aAAyC;EACjE,MAAM,aAAa,YAAY,aAAa;AAE5C,SAAOA,SAAO,KAAK,EACjB,KAAK,CAAC,EAAE,cAAc,YAAY,EAAE,EAAE,eAAe,YAAY,CAAC,EACnE,CAAC,CAAC,KAAK,EAAE,WAAW,IAAI,CAAC;;CAG5B,MAAM,oBAAwC;AAC5C,SAAOA,SAAO,KAAK,EACjB,QAAQ,EAAE,KAAK;GAAC;GAAW;GAAoB;GAAmB,EAAE,EACrE,CAAC;;CAGJ,MAAM,wBAAwB,SAAqC;AACjE,SAAOA,SAAO,KAAK;GACjB,QAAQ;GACR,KAAK,CAAC,EAAE,cAAc,SAAS,EAAE,EAAE,eAAe,SAAS,CAAC;GAC7D,CAAC;;CAGJ,MAAM,sBAAsB,SAAqC;AAC/D,SAAOA,SAAO,KAAK;GACjB,QAAQ,EACN,KAAK;IACH;IACA;IACA;IACA;IACA;IACD,EACF;GACD,KAAK,CAAC,EAAE,cAAc,SAAS,EAAE,EAAE,eAAe,SAAS,CAAC;GAC7D,CAAC;;CAGJ,MAAM,kBAAkB,SAAqC;AAC3D,SAAOA,SAAO,KAAK;GACjB,QAAQ;GACR,eAAe;GAChB,CAAC;;CAGJ,MAAM,qBAAqB,SAAqC;AAC9D,SAAOA,SAAO,KAAK,EACjB,KAAK,CAAC,EAAE,cAAc,SAAS,EAAE,EAAE,eAAe,SAAS,CAAC,EAC7D,CAAC,CACC,KAAK,EAAE,WAAW,IAAI,CAAC,CACvB,MAAM,EAAE;;CAGb,MAAM,qBAAqB,SAAkC;AAgB3D,UAfe,MAAMA,SAAO,UAAU,CACpC,EACE,QAAQ;GACN,eAAe;GACf,QAAQ;GACT,EACF,EACD,EACE,QAAQ;GACN,KAAK;GACL,eAAe,EAAE,MAAM,WAAW;GACnC,EACF,CACF,CAAC,EAEY,IAAI,iBAAiB;;CAgBrC,MAAM,iBAAiB,aAAqB;EAC1C,MAAM,SAAS,IAAI,KAAK,KAAK,KAAK,GAAG,YAAY;AAEjD,SAAOA,SAAO,WACZ;GACE,QAAQ;GACR,WAAW,EAAE,KAAK,QAAQ;GAC3B,EACD,EAAE,QAAQ,WAAW,CACtB;;;;;;AC3GL,MAAa,cAAc,KAAe,UAAe;AACvD,QAAO,IACJ,OACC,iBAAiB,YAAY,gBAAgB,QACzC,MAAM,aACN,IACL,CACA,KAAK;EACJ,SAAS;EACT,SACE,iBAAiB,WAAW,MAAM,UAAU;EAC9C;EACD,CAAC;;;;;ACZN,MAAa,yBAAyBC,YAAE,OAAO;CAC7C,QAAQA,YAAE,QAAQ;CAClB,MAAMA,YAAE,KAAK,CAAC,QAAQ,WAAW,CAAC;CAGlC,SAASA,YAAE,QAAQ,CAAC,UAAU;CAG9B,MAAMA,YACH,OAAO;EACN,QAAQA,YAAE,KAAK;EACf,UAAUA,YAAE,QAAQ;EACpB,UAAUA,YAAE,QAAQ;EACrB,CAAC,CACD,UAAU;CACd,CAAC;;;;ACLF,IAAa,oBAAb,MAA+B;CAC7B,YACE,AAAiBC,iBACjB,AAAiBC,WACjB;EAFiB;EACA;;CAGnB,MAAM,OAAO,OAA8B;AAEzC,MAAI,CADe,uBAAuB,UAAU,MAAM,CAC1C,QACd,OAAM,IAAI,gBAAgB,0BAA0B;AAGtD,UAAQ,IAAI,uBAAuB,MAAM,KAAK;EAE9C,MAAMC,iBAAsC,EAAE;AAE9C,MAAI,MAAM,SAASC,gBAAgB,MAAM;AACvC,OAAI,CAAC,MAAM,QACT,OAAM,IAAI,gBACR,8CACD;AAGH,kBAAe,UAAU,MAAM,QAAQ,MAAM,QAAQ;;AAGvD,MAAI,MAAM,SAASA,gBAAgB,UAAU;AAC3C,OAAI,CAAC,MAAM,KACT,OAAM,IAAI,gBACR,oDACD;AAGH,kBAAe,UAAU,MAAM,KAAK,UAAU,kBAAkB;IAC9D,QAAQ,MAAM,KAAK;IACnB,UAAU,MAAM,KAAK;IACrB,UAAU,MAAM,KAAK;IACtB,CAAC;;EAGJ,MAAM,QAAQ;GACZ,QAAQ,MAAM;GACd,MAAM,MAAM;GACZ,GAAG;GACJ;AAED,UAAQ,IAAI,yBAAyB,MAAM;AAE3C,SAAO,KAAK,gBAAgB,OAAO,MAAM;;CAG3C,MAAM,qBAAqB,KAAa;EACtC,MAAM,aAAa,MAAM,KAAK,gBAAgB,YAAY,IAAI;AAC9D,MAAI,CAAC,WAAY,OAAM,IAAI,cAAc,2BAA2B;AACpE,SAAO;;CAGT,MAAM,gBAAgB,YAAyB,OAAc;AAC3D,MAAI,UAAU,QAAS,OAAM,IAAI,mBAAmB;AACpD,MAAI,WAAW,SAAS,OACtB,OAAM,IAAI,gBAAgB,0CAA0C;EACtE,MAAM,UAAU,WAAW;AAC3B,MAAI,CAAC,QAAS,OAAM,IAAI,gBAAgB,qBAAqB;EAC7D,MAAM,EAAE,WAAW,2BACjB,MAAM,KAAK,UAAU,gBAAgB,QAAQ;AAE/C,SAAO;GAAE;GAAW;GAAW;;CAGjC,MAAM,YAAY,YAAyB,OAAc;AACvD,MAAI,UAAU,QAAS,OAAM,IAAI,mBAAmB;AACpD,MAAI,WAAW,SAAS,WACtB,OAAM,IAAI,gBAAgB,6CAA6C;EACzE,MAAM,UAAU,WAAW;AAC3B,MAAI,CAAC,QAAS,OAAM,IAAI,gBAAgB,qBAAqB;AAE7D,SAAO,EAAE,MADS,MAAM,QAAQ,QAAQ,EACd;;;;;;AC1D9B,MAAM,mBAAmB,IAAIC,gBAC3B;CACE,QAAQ;EACN,MAAMA,gBAAO,MAAM;EACnB,KAAK;EACL,UAAU;EACV,OAAO;EACR;CACD,MAAM;EAAE,MAAM;EAAQ,MAAM,CAAC,QAAQ,WAAW;EAAE;CAElD,SAAS,EACP,MAAM,QACP;CAGD,SAAS,EACP,MAAM,QACP;CACD,UAAU;EACR,MAAM;EACN,MAAM,CACJ,mBACA,0EACD;EACF;CAED,YAAY;EACV,MAAM;EACN,SAAS,KAAK;EACf;CAED,YAAY,EACV,MAAM,MACP;CACF,EACD,EAAE,YAAY,MAAM,CACrB;AAcD,MAAaC,eAAa,iBAAS,MACjC,cACA,iBACD;;;;AC9ED,IAAa,kBAAb,MAA6B;CAC3B,MAAM,OAAO,MAAiD;AAC5D,SAAOC,aAAW,OAAO,KAAK;;CAGhC,MAAM,QAAQ,IAAyC;AACrD,SAAOA,aAAW,SAAS,GAAG,CAAC,MAAM;;CAGvC,MAAM,YAAY,UAA+C;AAC/D,SAAOA,aAAW,QAAQ,EAAE,QAAQ,UAAU,CAAC,CAAC,MAAM;;CAGxD,MAAM,OACJ,IACA,MAC6B;AAC7B,SAAOA,aAAW,iBAAiB,EAAE,KAAK,IAAI,EAAE,MAAM;GACpD,KAAK;GACL,eAAe;GAChB,CAAC,CAAC,MAAM;;CAGX,MAAM,OAAO,IAAyC;AACpD,SAAOA,aAAW,kBAChB,IACA,EAAE,4BAAY,IAAI,MAAM,EAAE,EAC1B,EAAE,KAAK,MAAM,CACd,CAAC,MAAM;;;;;;ACxBZ,IAAa,qBAAb,MAAgC;CAC9B,AAAQ;CACR,AAAQ;CAER,cAAc;AACZ,OAAK,SAAS,QAAQ,IAAI;AAC1B,OAAK,oDACH,QAAQ,IAAI,cACZ,QAAQ,IAAI,0BACb;;CAGH,MAAM,kBAAkB,MAAgC;EACtD,MAAM,EAAE,QAAQ,UAAU,aAAa;EAEvC,MAAM,aAAa,GADH,eAAO,YAAY,CACL,GAAG;EAEjC,MAAM,EAAE,UAAU,MAAM,KAAK,SAAS,QACnC,KAAK,KAAK,OAAO,CACjB,OAAO,YAAY,QAAQ;GAC1B,aAAa;GACb,QAAQ;GACT,CAAC;AAEJ,MAAI,MAAO,OAAM;AAEjB,SAAO;;CAGT,MAAM,gBACJ,SACmD;EACnD,MAAM,MAAM;EACZ,MAAM,EAAE,MAAM,UAAU,MAAM,KAAK,SAAS,QACzC,KAAK,KAAK,OAAO,CACjB,gBAAgB,SAAS,KAAK,IAAI;AAErC,MAAI,MAAO,OAAM;AAEjB,SAAO;GAAE,WAAW,KAAK;GAAW,WAAW,GAAG,IAAI;GAAW;;;;;;ACxCrE,MAAMC,eAAa,IAAI,kBACrB,IAAI,iBAAiB,EACrB,IAAI,oBAAoB,CACzB;AACD,MAAMC,WAAS,IAAI,cAAc,IAAI,aAAa,EAAED,aAAW;AAE/D,MAAa,eAAe,OAAO,KAAkB,QAAkB;AACrE,KAAI;EACF,MAAM,OAAO,IAAI;AACjB,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EAEJ,MAAM,EAAE,OAAO,QAAQ,kBAAkB,IAAI;AAC7C,MAAI,CAAC,SAAS,CAAC,UAAU,CAAC,cACxB,QAAO,IACJ,OAAO,IAAI,CACX,KAAK,EAAE,OAAO,4CAA4C,CAAC;EAEhE,MAAM,eAAe,KAAK;AAE1B,MAAI,OAAO,UAAU,SACnB,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAEJ,MAAI,OAAO,iBAAiB,YAAY,OAAO,kBAAkB,SAC/D,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EAEJ,MAAM,SAAS,MAAMC,SAAO,aAC1B,OACA,OAAO,OAAO,EACd,cACA,cACD;AACD,MAAI,KAAK;GAAE,SAAS;GAAM;GAAQ,CAAC;UAC5B,OAAO;AACd,aAAW,KAAK,MAAM;;;;;;AC3C1B,MAAMC,eAAa,IAAI,kBACrB,IAAI,iBAAiB,EACrB,IAAI,oBAAoB,CACzB;AACD,MAAMC,WAAS,IAAI,cAAc,IAAI,aAAa,EAAED,aAAW;AAE/D,MAAa,kBAAkB,OAAO,KAAkB,QAAkB;AACxE,KAAI;AAEF,MAAI,CADS,IAAI,KAEf,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EACJ,MAAM,EAAE,OAAO,IAAI;AAEnB,MAAI,CAAC,MAAM,OAAO,OAAO,SACvB,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,qBAAqB,CAAC;EAG7D,MAAM,SAAS,MAAMC,SAAO,cAAc,GAAG;AAE7C,MAAI,CAAC,OACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,oBAAoB,CAAC;AAG5D,MAAI,KAAK,EAAE,QAAQ,OAAO,QAAQ,CAAC;UAC5B,OAAO;AACd,aAAW,KAAK,MAAM;;;;;;AC7B1B,MAAMC,eAAa,IAAI,kBACrB,IAAI,iBAAiB,EACrB,IAAI,oBAAoB,CACzB;AACD,MAAMC,WAAS,IAAI,cAAc,IAAI,aAAa,EAAED,aAAW;AAE/D,MAAa,qBAAqB,OAAO,KAAkB,QAAkB;AAC3E,KAAI;EACF,MAAM,OAAO,IAAI;AACjB,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EACJ,MAAM,EAAE,OAAO,IAAI;AACnB,MAAI,CAAC,MAAM,OAAO,OAAO,SACvB,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,qBAAqB,CAAC;EAG7D,MAAM,OAAO,MAAMC,SAAO,mBAAmB,IAAI,KAAK,GAAG;AACzD,MAAI,KAAK;GAAE,SAAS;GAAM;GAAM,CAAC;UAC1BC,KAAU;AACjB,MAAI,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,IAAI,SAAS,CAAC;;;;;;AClBhD,MAAMC,eAAa,IAAI,kBACrB,IAAI,iBAAiB,EACrB,IAAI,oBAAoB,CACzB;AACD,MAAMC,WAAS,IAAI,cAAc,IAAI,aAAa,EAAED,aAAW;AAE/D,eAAsB,kBAAkB,KAAkB,KAAe;AACvE,KAAI;EACF,MAAM,OAAO,IAAI;AACjB,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAGJ,UAAQ,IAAI,6BAA6B;EAEzC,MAAM,EAAE,aAAa,IAAI;AACzB,MAAI,CAAC,SACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAGJ,UAAQ,IAAI,2BAA2B;AAEvC,MAAI,OAAO,aAAa,YAAY,SAAS,MAAM,CAAC,WAAW,EAC7D,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAGJ,UAAQ,IAAI,2BAA2B;EAEvC,MAAM,EAAE,MAAM,YAAY,IAAI;AAE9B,UAAQ,IAAI,+BAA+B,MAAM,QAAQ;EAEzD,MAAME,kBAAwC;GAC5C;GACA;GACA,MAAM,IAAI,OACN;IACE,QAAQ,IAAI,KAAK;IACjB,UAAU,IAAI,KAAK;IACnB,UAAU,IAAI,KAAK;IACpB,GACD;GACL;EAED,MAAM,aAAa,MAAMD,SAAO,iBAC9B,UACA,KAAK,IACL,gBACD;AAED,UAAQ,IAAI,4CAA4C,WAAW;AAEnE,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACT,MAAM;GACP,CAAC;UACK,OAAO;AACd,aAAW,KAAK,MAAM;;;;;;ACtE1B,MAAME,eAAa,IAAI,kBACrB,IAAI,iBAAiB,EACrB,IAAI,oBAAoB,CACzB;AACD,MAAMC,WAAS,IAAI,cAAc,IAAI,aAAa,EAAED,aAAW;AAC/D,eAAsB,kBAAkB,KAAkB,KAAe;AACvE,SAAQ,IAAI,QAAQ;AACpB,KAAI;EACF,MAAM,OAAO,IAAI;AACjB,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AACJ,UAAQ,IAAI,iBAAiB;EAE7B,MAAM,WAAW,KAAK;EAEtB,MAAM,EAAE,aAAa,IAAI;AACzB,MAAI,CAAC,YAAY,CAAC,SAChB,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAEJ,MAAI,OAAO,aAAa,YAAY,OAAO,aAAa,SACtD,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAEJ,UAAQ,IAAI,oCAAoC;EAEhD,MAAM,aAAa,MAAMC,SAAO,aAAa,UAAU,SAAS;AAChE,MAAI,OAAO,IAAI,CAAC,KAAK;GACnB,SAAS;GACT,UACE;GACF;GACD,CAAC;UACK,OAAO;AACd,aAAW,KAAK,MAAM;;;;;;ACzC1B,MAAM,gBAAgB,QAAQ,IAAI;AAClC,MAAM,YAAY,CAAC,QAAQ,IAAI;AAE/B,SAAgB,iBAAiB,SAAsC;AACrE,QAAOC,qBAAI,KAAK,SAAS,eAAe,EACtC,WACD,CAAC;;AAGJ,SAAgB,mBAAmB,OAAoC;AAErE,QADgBA,qBAAI,OAAO,OAAO,cAAc;;;;;ACRlD,eAAsB,YACpB,KACA,KACA,MACA;AACA,KAAI;EACF,MAAMC,eAAa,QAAQ,IAAI;EAC/B,MAAM,eAAe,IAAI,UAAUA;AAEnC,MAAI,CAAC,aACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,SAAS,mBAAmB,CAAC;EAG7D,MAAM,UAAU,mBAAmB,aAAa;EAEhD,MAAM,OAAO,MAAMC,OAAK,SAAS,QAAQ,IAAI;AAE7C,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,SAAS,mBAAmB,CAAC;AAG7D,MAAI,KAAK,SACP,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,SAAS,kBAAkB,CAAC;AAG5D,MAAI,KAAK,aAAa,iBAAiB,QAAQ,EAC7C,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,SAAS,mBAAmB,CAAC;AAG7D,MAAI,OAAO;GACT,IAAI,KAAK;GACT,QAAQ,KAAK;GACd;AAED,QAAM;SACA;AACN,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,SAAS,8BAA8B,CAAC;;;;;;ACtC1E,MAAMC,eAAa,IAAI,kBACrB,IAAI,iBAAiB,EACrB,IAAI,oBAAoB,CACzB;AACD,MAAMC,WAAS,IAAI,cAAc,IAAI,aAAa,EAAED,aAAW;AAE/D,eAAsB,eAAe,KAAkB,KAAe;AACpE,KAAI;EACF,MAAM,OAAO,IAAI;AACjB,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EAEJ,MAAM,UAAU,MAAMC,SAAO,oBAAoB,KAAK,OAAO;AAC7D,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACT;GACD,CAAC;UACK,OAAO;AACd,aAAW,KAAK,MAAM;;;AAI1B,eAAsB,gBAAgB,KAAkB,KAAe;AACrE,KAAI;AAEF,MAAI,CADS,IAAI,KAEf,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EACJ,MAAM,EAAE,aAAa,IAAI;AACzB,MAAI,CAAC,YAAY,OAAO,aAAa,SACnC,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK,EAAE,OAAO,qBAAqB,CAAC;EAG7D,MAAM,SAAS,MAAMA,SAAO,cAAc,SAAS;AACnD,MAAI,CAAC,OACH,QAAO,IACJ,OAAO,IAAI,CACX,KAAK;GAAE,SAAS;GAAO,SAAS;GAAoB;GAAQ,CAAC;AAElE,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACT;GACD,CAAC;UACK,OAAO;AACd,aAAW,KAAK,MAAM;;;AAI1B,eAAsB,kBAAkB,KAAkB,KAAe;AACvE,SAAQ,IAAI,oBAAoB;AAChC,KAAI;EACF,MAAM,OAAO,IAAI;AACjB,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EAEJ,MAAM,UAAU,MAAMA,SAAO,kBAAkB,KAAK,OAAO;AAC3D,UAAQ,IAAI,QAAQ;AAEpB,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACT;GACD,CAAC;UACK,OAAO;AACd,aAAW,KAAK,MAAM;;;;;;AChF1B,MAAM,6BAAgB;CACpB,SAAS,eAAO,eAAe;CAC/B,QAAQ,EACN,UAAU,KAAK,OAAO,MACvB;CACF,CAAC,CAAC,OAAO,OAAO;AAEjB,SAAgB,aAAa,KAAc,KAAe,MAAoB;AAC5E,QAAO,KAAK,MAAM,QAAQ;AACxB,MAAI,IACF,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS,IAAI;GACd,CAAC;EAIJ,MAAM,EAAE,SAAS,IAAI;AAErB,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAGJ,MAAI,SAAS,cAAc,CAAC,IAAI,KAC9B,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAGJ,QAAM;GACN;;;;;AC5BJ,MAAMC,eAAa,IAAI,kBACrB,IAAI,iBAAiB,EACrB,IAAI,oBAAoB,CACzB;AACD,MAAMC,WAAS,IAAI,cAAc,IAAI,aAAa,EAAED,aAAW;AAE/D,MAAa,oBAAoB,OAAO,KAAkB,QAAkB;AAC1E,KAAI;EACF,MAAM,OAAO,IAAI;AACjB,MAAI,CAAC,KACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EAEJ,MAAM,QAAQ,MAAMC,SAAO,kBAAkB,KAAK,OAAO;AAEzD,MAAI,CAAC,MACH,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;AAGJ,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACT;GACD,CAAC;UACK,OAAO;AACd,aAAW,KAAK,MAAM;;;;;;ACtB1B,MAAMC,8BAAyB;AAE/B,OAAO,KAAK,WAAW,aAAa,aAAa;AAEjD,OAAO,KACL,6BACA,aACA,cACA,kBACD;AAED,OAAO,IAAI,cAAc,aAAa,kBAAkB;AAExD,OAAO,IAAI,eAAe,aAAa,gBAAgB;AAEvD,OAAO,KAAK,oBAAoB,aAAa,kBAAkB;AAE/D,OAAO,KAAK,gBAAgB,aAAa,mBAAmB;AAE5D,OAAO,IAAI,YAAY,aAAa,kBAAkB;AACtD,OAAO,IAAI,cAAc,aAAa,gBAAgB;AAEtD,OAAO,IAAI,KAAK,aAAa,eAAe;AAkB5C,4BAAe;;;;ACpDf,IAAa,cAAb,MAAyB;CACvB,YAAY,AAAiBC,WAAsB;EAAtB;;CAE7B,MAAM,iBAAiB,eAAuC;AAC5D,MAAI,CAAC,cACH,OAAM,IAAI,MAAM,6BAA6B;EAE/C,MAAM,OAAO,MAAM,KAAK,UAAU,aAAa,cAAc;AAC7D,MAAI,KAAK,SACP,OAAM,IAAI,MAAM,iBAAiB;AAEnC,SAAO;;CAGT,SAAS,MAAqB;AAC5B,MAAI,KAAK,SACP,OAAM,IAAI,MAAM,iBAAiB;EAGnC,MAAM,eAAe,KAAK,aAAa;AASvC,SAPqB,iBAAiB;GACpC,KAAK,KAAK,IAAI,UAAU;GACxB,QAAQ,KAAK;GACb,GAAG;GACH,KAAK,KAAK,KAAK;GAChB,CAAC;;CAKJ,MAAM,gBAAgB,eAA8C;AAClE,MAAI,CAAC,cACH,OAAM,IAAI,MAAM,6BAA6B;EAE/C,MAAM,OAAO,MAAM,KAAK,UAAU,YAAY,cAAc;AAC5D,MAAI,CAAC,KAAM,OAAM,IAAI,MAAM,iBAAiB;AAC5C,SAAO;;CAGT,MAAM,YAAY,QAAuC;AACvD,MAAI,CAAC,OACH,OAAM,IAAI,MAAM,sBAAsB;EAExC,MAAM,OAAO,MAAM,KAAK,UAAU,QAAQ,OAAO;AACjD,MAAI,CAAC,KAAM,OAAM,IAAI,MAAM,iBAAiB;AAC5C,SAAO;;CAGT,MAAM,QAAQ,eAA8C;AAC1D,SAAO,KAAK,UAAU,gBAAgB,eAAe,KAAK;;CAG5D,MAAM,UAAU,eAA8C;AAC5D,SAAO,KAAK,UAAU,gBAAgB,eAAe,MAAM;;CAG7D,MAAM,sBAAsB,QAAuC;AACjE,MAAI,CAAC,OACH,OAAM,IAAI,MAAM,sBAAsB;AAExC,SAAO,KAAK,UAAU,sBAAsB,OAAO;;;;;;AChEvD,IAAa,YAAb,MAAuB;CACrB,MAAM,WAAW,eAAuC;AAEtD,SADa,MAAMC,OAAK,OAAO,EAAE,eAAe,CAAC;;CAInD,MAAM,YAAY,eAA8C;AAC9D,SAAO,MAAMA,OAAK,QAAQ,EAAE,eAAe,CAAC;;CAG9C,MAAM,QAAQ,QAAuC;AACnD,SAAO,MAAMA,OAAK,QAAQ,EAAE,KAAK,QAAQ,CAAC;;CAG5C,MAAM,aAAa,eAAuC;EACxD,MAAM,eAAe,MAAMA,OAAK,QAAQ,EAAE,eAAe,CAAC;AAE1D,MAAI,aAAc,QAAO;AAGzB,SADa,MAAMA,OAAK,OAAO,EAAE,eAAe,CAAC;;CAInD,MAAM,mBACJ,eACA,WACuB;AACvB,MAAI,CAAC,UAEH,QAAOA,OAAK,iBACV,EAAE,eAAe,EACjB,EAAE,MAAM,EAAE,cAAc,MAAM,EAAE,EAChC,EAAE,KAAK,MAAM,CACd;AAiBH,SAboB,MAAMA,OAAK,iBAC7B,EAAE,eAAe,EACjB,EACE,MAAM,EACJ,cAAc;GACZ;GACA,2BAAW,IAAI,MAAM;GACtB,EACF,EACF,EACD;GAAE,KAAK;GAAM,QAAQ;GAAO,CAC7B;;CAKH,MAAM,gBACJ,eACA,UACuB;AACvB,SAAO,MAAMA,OAAK,iBAChB,EAAE,eAAe,EACjB,EAAE,UAAU,EACZ,EAAE,KAAK,MAAM,CACd;;CAGH,MAAM,sBAAsB,QAAuC;AACjE,SAAO,MAAMA,OAAK,kBAChB,QACA,EAAE,MAAM,EAAE,6BAA6B,GAAG,EAAE,EAC5C,EAAE,KAAK,MAAM,CACd;;;;;;AClEL,MAAMC,SAAO,IAAI,YAAY,IAAI,WAAW,CAAC;AAC7C,MAAMC,eAAa,QAAQ,IAAI;AAC/B,MAAa,YAAY,OAAO,KAAc,QAAkB;AAC9D,KAAI;EACF,MAAM,EAAE,kBAAkB,IAAI;AAE9B,MAAI,CAAC,iBAAiB,OAAO,kBAAkB,SAC7C,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EAEJ,MAAM,OAAO,MAAMD,OAAK,iBAAiB,cAAc;AAEvD,MAAI,CAAC,KACH,QAAO,IACJ,OAAO,IAAI,CACX,KAAK;GAAE,SAAS;GAAO,SAAS;GAA4B,CAAC;EAGlE,MAAM,eAAeA,OAAK,SAAS,KAAK;AAExC,MAAI,CAAC,aACH,QAAO,IACJ,OAAO,IAAI,CACX,KAAK;GAAE,SAAS;GAAO,SAAS;GAA0B,CAAC;AAIhE,MAAI,OAAOC,cAAY,cAAc;GACnC,UAAU;GACV,QAAQ,QAAQ,IAAI,aAAa;GACjC,UAAU,QAAQ,IAAI,aAAa,eAAe,WAAW;GAC7D,QAAQ,OAAc,KAAK;GAC5B,CAAC;AAEF,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACT,MAAM;IAAE,IAAI,KAAK;IAAK,QAAQ,KAAK;IAAe;GACnD,CAAC;UACK,OAAO;AACd,UAAQ,IAAI,0BAA0B,MAAM;AAC5C,SAAO,WAAW,KAAK,MAAM;;;;;;AC1CjC,MAAM,OAAO,IAAI,YAAY,IAAI,WAAW,CAAC;AAC7C,MAAM,aAAa,QAAQ,IAAI;AAE/B,MAAa,aAAa,OAAO,KAAc,QAAkB;AAC/D,KAAI;EACF,MAAM,QAAQ,IAAI,QAAQ;AAE1B,MAAI,OAAO;GACT,MAAM,UAAU,mBAAmB,MAAM;GACzC,MAAM,OAAO,MAAM,KAAK,YAAY,QAAQ,IAAI;AAChD,OAAI,KAEF,OAAM,KAAK,sBAAsB,MAAM,IAAI,UAAU,CAAC;;AAK1D,MAAI,YAAY,YAAY;GAC1B,UAAU;GACV,QAAQ,QAAQ,IAAI,aAAa;GACjC,UAAU,QAAQ,IAAI,aAAa,eAAe,WAAW;GAC9D,CAAC;AAEF,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;UACK,OAAO;AACd,UAAQ,IAAI,2BAA2B,MAAM;AAC7C,SAAO,WAAW,KAAK,MAAM;;;;;;AC7BpB,IAAI,YAAY,IAAI,WAAW,CAAC;AAC1B,QAAQ,IAAI;AAC/B,MAAa,aAAa,OAAO,KAAkB,QAAkB;AACnE,KAAI;AAEF,MAAI,CADS,IAAI,KAEf,QAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACV,CAAC;EAEJ,MAAM,KAAK,IAAI,MAAM;EACrB,MAAM,gBAAgB,IAAI,MAAM;AAEhC,SAAO,IAAI,OAAO,IAAI,CAAC,KAAK;GAC1B,SAAS;GACT,SAAS;GACT,MAAM;IAAE;IAAI,QAAQ;IAAe;GACpC,CAAC;UACK,OAAO;AACd,UAAQ,IAAI,0BAA0B,MAAM;AAC5C,SAAO,WAAW,KAAK,MAAM;;;;;;ACrBjC,MAAMC,iCAA4B;AAElC,UAAU,KAAK,WAAW,UAAU;AACpC,UAAU,KAAK,WAAW,WAAW;AACrC,UAAU,IAAI,YAAY,aAAa,WAAW;AAElD,0BAAe;;;;ACCf,MAAMC,4BAAwB;AAC9B,IAAI,IAAI,kBAAkB,MAAc,UAAe;AAErD,KAAI,OAAO,UAAU,SACnB,QAAO,MAAM,UAAU;AAEzB,QAAO;EACP;AAEF,MAAM,iBAAiB,CAAC,8BAA8B,wBAAwB;AAE9E,IAAI,sBACG;CACH,SAAS,QAAQ,aAAa;AAC5B,MAAI,CAAC,UAAU,eAAe,SAAS,OAAO,CAC5C,UAAS,MAAM,KAAK;MAEpB,0BAAS,IAAI,MAAM,sBAAsB,CAAC;;CAG9C,aAAa;CACd,CAAC,CACH;AAED,IAAI,IAAI,gBAAQ,WAAW,EAAE,UAAU,OAAO,CAAC,CAAC;AAChD,IAAI,gCAAkB,CAAC;AACvB,IAAI,IAAI,gBAAQ,MAAM,CAAC;AAoBvB,MAAM,yCAlBiB;CACrB,mBAAmB;EACjB,SAAS;EACT,MAAM;GACJ,OAAO;GACP,SAAS;GACT,aAAa;GACd;EACD,SAAS,CACP;GACE,KAAK;GACL,aAAa;GACd,CACF;EACF;CACD,MAAM,CAAC,oBAAoB;CAC5B,CAE+C;AAChD,IAAI,IAAI,aAAaC,2BAAU,OAAOA,2BAAU,MAAM,YAAY,CAAC;AAEnE,IAAI,IAAI,MAAM,KAAK,QAAQ;AACzB,KAAI,KAAK,gCAAgC;EACzC;AAGF,IAAI,IAAI,UAAUC,oBAAY;AAC9B,IAAI,IAAI,kBAAkBC,sBAAa;AACvC,IAAI,IAAI,gBAAgBC,oBAAW;AAGnC,MAAM,SAAS,KAAK,aAAa,IAAI;AACrC,MAAM,MAAM,IAAIC,GAAU,gBAAgB,EAAE,QAAQ,CAAC;AAErD,MAAM,aAAa,QACjB,KAAK,UAAU,MAAM,KAAK,UACxB,OAAO,UAAU,WAAW,MAAM,UAAU,GAAG,MAChD;AAIH,IAAI,GAAG,eAAe,SAA4B;AAChD,SAAQ,IAAI,6BAA6B;AAEzC,MAAG,GAAG,WAAW,OAAO,YAAoB;AAC1C,MAAI;GACF,MAAM,gBAAgB,KAAK,MAAM,QAAQ,UAAU,CAAC;AACpD,WAAQ,IAAI,kBAAkB,cAAc;GAC5C,MAAM,EAAE,MAAM,OAAO,SAAS,cAAc;AAE5C,WAAQ,MAAR;IAEE,KAAK;AACH,SAAI,CAAC,SAAS,QACZ,QAAO,UAAUC,MAAI,oBAAoB,UAAU;AACrD,SAAI;MACF,MAAM,MAAM,MAAM,gBAAgB,uBAAuB,CACvD,QAAQ,QACT,CAAC;MAEF,MAAM,QAAQ,CACZ;OACE,SAAS,IAAI,QAAQ,IAAI;OACzB,2DAA4B,IAAI,QAAQ,IAAI,WAAW,GAAG;OAC3D,CACF;AAED,cAAQ,IAAI,MAAM;AAElB,WAAG,KACD,UAAU;OACR,MAAM;OACN;OACA,MAAM;OACP,CAAC,CACH;cACMC,KAAU;AACjB,gBAAUD,MAAI,IAAI,SAAS,UAAU;;AAEvC;IAGF,KAAK;AACH,SAAI,CAAC,SAAS,QACZ,QAAO,UAAUA,MAAI,oBAAoB,UAAU;AACrD,SAAI;AACF,YAAM,gBAAgB,aAAa,QAAQ,SAASA,KAAG;MAGvD,MAAM,iBAAiB,MAAM,gBAAgB,uBAC3C,CAAC,QAAQ,QAAQ,CAClB;AACD,WAAG,KACD,KAAK,UAAU;OACb,MAAM;OACN,SAAS,QAAQ;OACjB,MAAM;OACP,CAAC,CACH;cACMC,KAAU;AACjB,gBAAUD,MAAI,IAAI,SAAS,UAAU;;AAEvC;IAGF,KAAK;AACH,SAAI,MAAO,iBAAgB,UAAU,OAAOA,KAAG;AAC/C;IAEF,KAAK;AACH,SAAI,MAAO,iBAAgB,YAAY,OAAOA,KAAG;AACjD;IAEF,QACE,MAAG,KAAK,KAAK,UAAU,EAAE,OAAO,wBAAwB,CAAC,CAAC;;WAEvD,OAAO;AACd,WAAQ,MAAM,sCAAsC,MAAM;;GAE5D;AAEF,MAAG,GAAG,eAAe;AACnB,UAAQ,IAAI,gCAAgC;AAE5C,kBAAgB,WAAWA,KAAG;AAO9B,EAL8C;GAC5C;GACA;GACA;GACD,CACc,SAAS,UAAU;AAChC,mBAAgB,YAAY,OAAOA,KAAG;IACtC;GACF;EACF;AAGF,SAAS,UACP,MACA,SACA,WACA;AACA,KAAIA,KAAG,eAAeD,GAAU,UAAU,KACxC,MAAG,KAAK,KAAK,UAAU;EAAE,MAAM;EAAS;EAAS;EAAW,CAAC,CAAC;;;;;AC/KlE,MAAM,aAAa,IAAI,kBACrB,IAAI,iBAAiB,EACrB,IAAI,oBAAoB,CACzB;AACD,MAAM,SAAS,IAAI,cAAc,IAAI,aAAa,EAAE,WAAW;AAE/D,IAAI,oBAAoB;AAExB,eAAsB,sBAAsB;AAC1C,SAAQ,IAAI,iCAAiC;AAG7C,KAAI;AACF,QAAM,gBAAgB,SAAS;UACxB,KAAK;AACZ,UAAQ,MAAM,kCAAkC,IAAI;AACpD;;CAGF,MAAM,MAAM,gBAAgB,cAAc;CAI1C,MAAM,cADe,MAAM,aAAa,QAAQ,EAAE,CAAC,GAClB,aAAa,EAAE,EAC7C,KAAK,MAAM,OAAO,EAAE,CAAC,MAAM,CAAC,CAC5B,QAAQ,MAAM,EAAE,SAAS,EAAE;AAE9B,SAAQ,IAAI,mCAAmC,UAAU;AAEzD,KAAI,UAAU,SAAS,EACrB,KAAI;AACF,QAAM,qBAAqB,KAAK,UAAU;UACnC,KAAK;AACZ,UAAQ,MAAM,+CAA+C,IAAI;;KAGnE,SAAQ,KAAK,0CAA0C;AAIzD,KAAI,CAAC,mBAAmB;AACtB,sBAAoB;AAGpB,MAAI,iBAAiB,iBAAiB,OAAO,UAAe;AAC1D,OAAI;IACF,MAAM,QAAQ,OAAO,MAAM,SAAS,EAAE;AACtC,QAAI,CAAC,MAAM,OAAQ;IAEnB,MAAM,iCAAiB,IAAI,KAA4B;AAEvD,SAAK,MAAM,KAAK,OAAO;KACrB,MAAM,UAAU,EAAE,SAAS,UAAU;AACrC,SAAI,CAAC,QAAS;KAEd,MAAMG,OAAoB;MACxB,MAAM,EAAE,SAAS;MACjB,OAAO,EAAE,SAAS;MAClB,QAAQ,OAAO,EAAE,OAAO;MACxB;MACA,eAAe;MACf,UAAU;MACX;AAED,SAAI,CAAC,eAAe,IAAI,QAAQ,CAAE,gBAAe,IAAI,SAAS,EAAE,CAAC;AACjE,oBAAe,IAAI,QAAQ,CAAE,KAAK,KAAK;;AAGzC,SAAK,MAAM,CAAC,SAAS,UAAU,eAAe,SAAS,EAAE;KACvD,MAAM,SAAS,MAAM,OAAO,mBAAmB,QAAQ;AACvD,SAAI,CAAC,OAAQ;AAEb,WAAM,OAAO,mBAAmB,QAAQ,MAAM;;YAEzC,KAAK;AACZ,YAAQ,MAAM,oCAAoC,IAAI;;IAExD;AAGF,MAAI;AACF,SAAM,IAAI,6BAA6B,KAAK;AAE5C,OAAI,iBAAiB,yBAAyB,YAAY,GAMxD;WACK,KAAK;AACZ,WAAQ,MAAM,wCAAwC,IAAI;;;AAI9D,SAAQ,IAAI,kCAAkC;;;;;ACvGhD,MAAM,wBAAwB,QAAQ,IAAI,2BAA2B;AAErE,MAAa,YAAY,YAAY;AACnC,KAAI;AACF,QAAM,iBAAS,QAAQ,sBAAsB;AAC7C,UAAQ,IAAI,0BAA0B;UAC/B,OAAO;AACd,UAAQ,MAAM,6BAA6B,MAAM;AACjD,UAAQ,KAAK,EAAE;;;;;;ACJnB,MAAM,cAAc,IAAI,aAAa;AACrC,MAAM,gBAAgB,IAAI,cAAc,YAAY;;;;;;;;AASpDC,kBAAK,SAAS,eAAe,YAAY;AACvC,SAAQ,IAAI,oDAAmC,IAAI,MAAM,EAAC,aAAa,GAAG;AAE1E,KAAI;EACF,MAAM,UAAU,MAAM,YAAY,mBAAmB;AAErD,MAAI,QAAQ,WAAW,GAAG;AACxB,WAAQ,IAAI,gDAAgD;AAC5D;;AAGF,OAAK,MAAM,UAAU,QACnB,KAAI;AACF,SAAM,cAAc,qBAAqB,OAAO;AAGhD,WAAQ,IACN,+BAA+B,OAAO,SAAS,cAAc,OAAO,SACrE;WACM,WAAW;AAClB,WAAQ,MACN,iDAAiD,OAAO,SAAS,IACjE,UACD;;UAGE,KAAK;AACZ,UAAQ,MAAM,uCAAuC,IAAI;;EAE3D;AAEF,QAAQ,IAAI,+DAA+D;;;;AC3C3E,MAAM,OAAO,QAAQ,IAAI,OAAO,SAAS,QAAQ,IAAI,MAAM,GAAG,GAAG;AAIjE,MAAM,OAAO,YAAY;AACvB,KAAI;AACF,UAAQ,IAAI,6BAA6B;AACzC,QAAM,gBAAgB,SAAS;AAC/B,UAAQ,IAAI,0BAA0B,gBAAgB,eAAe,GAAG;AAExE,QAAM,WAAW;AACjB,QAAM,qBAAqB;UAEpB,OAAO;AACd,UAAQ,MAAM,wCAAwC,MAAM;;AAI9D,QAAO,OAAO,MAAM,iBAAiB;AACnC,UAAQ,IAAI,6BAA6B,OAAO;AAChD,UAAQ,IAAI,2CAA2C;GACvD;;AAGJ,MAAM,CAAC,MAAM,QAAQ,MAAM"}